<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Pseudocode Animator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .speed-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .speed-control label {
            color: #2c3e50;
            font-weight: bold;
            font-size: 16px;
        }

        .speed-slider {
            width: 250px;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #e74c3c, #f39c12, #2ecc71);
            outline: none;
            cursor: pointer;
            appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3498db, #2980b9);
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            border: 3px solid white;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            background: linear-gradient(135deg, #2980b9, #3498db);
            transform: scale(1.2);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }

        #speedLabel {
            color: white;
            font-weight: bold;
            font-size: 16px;
            min-width: 90px;
            text-align: center;
            padding: 10px 18px;
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            border-radius: 25px;
            box-shadow: 0 3px 10px rgba(116, 185, 255, 0.3);
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            padding: 20px;
            min-height: 600px;
        }

        .input-panel, .pseudocode-panel, .variables-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }

        .panel-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .code-input {
            width: 100%;
            height: 400px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            resize: vertical;
            background: #fff;
            line-height: 1.5;
        }

        .code-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.2);
        }

        .validation-message {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
        }

        .validation-message.error {
            background: #fee;
            border: 1px solid #fcc;
            color: #c33;
        }

        .validation-message.success {
            background: #efe;
            border: 1px solid #cfc;
            color: #3c3;
        }

        .validation-message.warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .pseudocode-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 0;
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #333;
        }

        .pseudocode-line {
            display: flex;
            align-items: center;
            margin: 0;
            transition: all 0.3s ease;
            font-size: 14px;
            line-height: 1.4;
            min-height: 28px;
            border-left: 4px solid transparent;
        }

        .line-number {
            min-width: 40px;
            padding: 6px 8px;
            background: #2d2d2d;
            color: #858585;
            text-align: right;
            font-size: 12px;
            border-right: 1px solid #444;
            cursor: pointer;
            user-select: none;
        }

        .line-number:hover {
            background: #3d3d3d;
            color: #fff;
        }

        .line-number.breakpoint {
            background: #e74c3c;
            color: white;
        }

        .line-number.breakpoint::before {
            content: "‚óè";
            margin-right: 4px;
        }

        .line-content {
            flex: 1;
            padding: 6px 12px;
            background: #1e1e1e;
            color: #d4d4d4;
            white-space: pre;
        }

        .pseudocode-line.current {
            background: #2d4f3e;
            border-left-color: #fdcb6e;
        }

        .pseudocode-line.current .line-content {
            background: #2d4f3e;
        }

        .pseudocode-line.current .line-number {
            background: #fdcb6e;
            color: #2c3e50;
            font-weight: bold;
        }

        .pseudocode-line.completed {
            opacity: 0.6;
        }

        .pseudocode-line.completed .line-content {
            background: #1a3d2e;
        }

        .pseudocode-line.error {
            background: #4a2c2c;
            border-left-color: #e74c3c;
        }

        .pseudocode-line.error .line-content {
            background: #4a2c2c;
        }

        /* Syntax Highlighting */
        .keyword { color: #569cd6; font-weight: bold; }
        .string { color: #ce9178; }
        .number { color: #b5cea8; }
        .operator { color: #dcdcaa; }
        .variable { color: #9cdcfe; }
        .assignment { color: #d4d4d4; font-weight: bold; }
        .comment { color: #6a9955; font-style: italic; }

        .variable-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: white;
            border-radius: 8px;
            border: 2px solid #ddd;
            transition: all 0.3s ease;
        }

        .variable-item.updated {
            border-color: #e17055;
            background: #ffeaa7;
            transform: scale(1.02);
            box-shadow: 0 3px 10px rgba(225, 112, 85, 0.2);
        }

        .variable-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .variable-value {
            font-weight: bold;
            color: #e17055;
            font-size: 1.1rem;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(116, 185, 255, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7);
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(162, 155, 254, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894, #00a085);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.4);
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
        }

        .btn-info:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(23, 162, 184, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .output {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Consolas', monospace;
            min-height: 60px;
            border: 2px solid #4a5568;
        }

        .output-title {
            color: #81c784;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .examples {
            margin-top: 15px;
        }

        .example-btn {
            display: block;
            width: 100%;
            margin-bottom: 8px;
            padding: 8px 12px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .example-btn:hover {
            background: #bbdefb;
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
        }

        .debug-info {
            background: #2c3e50;
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
        }

        .step-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 15px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        .modal-header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            margin: -20px -20px 20px -20px;
            padding: 20px;
            border-radius: 15px 15px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .close {
            color: white;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            opacity: 0.7;
        }

        .keyword-section {
            margin-bottom: 25px;
        }

        .keyword-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .keyword-item {
            background: #f8f9fa;
            margin: 8px 0;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .keyword-syntax {
            font-family: 'Consolas', monospace;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .keyword-description {
            color: #666;
            font-size: 14px;
        }

        .keyword-example {
            font-family: 'Consolas', monospace;
            background: #e8f4f8;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 13px;
            border: 1px solid #d4e6ea;
        }

        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 200px;
            }

            .speed-control {
                flex-direction: column;
                gap: 10px;
            }

            .speed-slider {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Mathematical Pseudocode Animator</h1>
            <p>Write mathematically correct pseudocode and watch it execute step by step</p>
        </div>

        <div class="controls">
            <button class="btn btn-success" id="parseBtn">Parse Code</button>
            <button class="btn btn-primary" id="startBtn" disabled>Start</button>
            <button class="btn btn-primary" id="nextBtn" disabled>Next Step</button>
            <button class="btn btn-warning" id="prevBtn" disabled>Step Back</button>
            <button class="btn btn-primary" id="autoBtn" disabled>Auto Run</button>
            <button class="btn btn-secondary" id="resetBtn">Reset</button>
            <button class="btn btn-info" id="helpBtn">üìñ Help & Keywords</button>
        </div>

        <div class="speed-control">
            <label for="speedSlider">Auto Run Speed:</label>
            <input type="range" id="speedSlider" min="1" max="10" value="5" class="speed-slider">
            <span id="speedLabel">Normal</span>
        </div>

        <div class="content">
            <div class="input-panel">
                <div class="panel-title">Write Your Pseudocode</div>
                <textarea id="codeInput" class="code-input" placeholder="Enter your pseudocode here...

Example:
x ‚Üê 5
y ‚Üê 10
sum ‚Üê x + y
square ‚Üê x ^ 2
OUTPUT sum
OUTPUT square

Supported commands:
‚Ä¢ variable ‚Üê value
‚Ä¢ PRINT variable/value  
‚Ä¢ OUTPUT variable/value
‚Ä¢ IF condition THEN ... END IF
‚Ä¢ WHILE condition DO ... END WHILE
‚Ä¢ FOR variable ‚Üê start TO end DO ... END FOR

Boolean logic:
‚Ä¢ AND, OR for combining conditions
‚Ä¢ Use parentheses for grouping: (x > 5 AND y < 10) OR z = 0

Use ‚Üê for assignment, = for equality, ^ for powers
Click line numbers to set breakpoints!"></textarea>
                <div id="validationMessage" class="validation-message"></div>
                
                <div class="examples">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">Quick Examples:</div>
                    <button class="example-btn" data-example="simple">Simple Calculation</button>
                    <button class="example-btn" data-example="power">Powers & Exponents</button>
                    <button class="example-btn" data-example="loop">While Loop</button>
                    <button class="example-btn" data-example="factorial">Factorial</button>
                    <button class="example-btn" data-example="squares">Square Numbers</button>
                    <button class="example-btn" data-example="logical">Logical Operators (AND/OR)</button>
                </div>
                
                <div class="help-text">
                    <strong>Instructions:</strong> Click line numbers to set breakpoints. Use Step Back to undo steps. 
                    Syntax highlighting shows different code elements in color.
                </div>
            </div>

            <div class="pseudocode-panel">
                <div class="panel-title">Processed Code</div>
                <div class="pseudocode-container" id="pseudocode"></div>
                
                <div class="debug-info">
                    <div class="step-info">
                        <span>Step: <span id="stepCounter">0</span></span>
                        <span>Breakpoints: <span id="breakpointCount">0</span></span>
                    </div>
                    <div>Status: <span id="executionStatus">Ready</span></div>
                </div>
                
                <div class="output">
                    <div class="output-title">Output:</div>
                    <div id="output"></div>
                </div>
            </div>

            <div class="variables-panel">
                <div class="panel-title">Variables</div>
                <div id="variables"></div>
            </div>
        </div>

        <!-- Help Modal -->
        <div id="helpModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <span class="close">&times;</span>
                    <h2>Mathematical Pseudocode Syntax Guide</h2>
                </div>

                <div class="keyword-section">
                    <h3>New Features</h3>
                    
                    <div class="keyword-item">
                        <div class="keyword-syntax">Boolean Logic (AND/OR)</div>
                        <div class="keyword-description">Combine multiple conditions using AND and OR operators. Use parentheses for grouping.</div>
                        <div class="keyword-example">IF x > 5 AND y < 10 THEN<br>IF a = 1 OR b = 2 THEN<br>IF (x > 0 AND y > 0) OR z = 0 THEN</div>
                    </div>
                    
                    <div class="keyword-item">
                        <div class="keyword-syntax">Breakpoints</div>
                        <div class="keyword-description">Click on line numbers to set/remove breakpoints. Execution will pause BEFORE executing the breakpoint line.</div>
                        <div class="keyword-example">Click the gray line number ‚Üí Red dot appears ‚Üí Execution pauses before that line</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Step Back</div>
                        <div class="keyword-description">Undo the last execution step to review what happened.</div>
                        <div class="keyword-example">Use "Step Back" button to reverse the last operation</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Syntax Highlighting</div>
                        <div class="keyword-description">Different parts of code are colored: keywords (blue), strings (orange), numbers (green), operators (yellow).</div>
                        <div class="keyword-example">IF (blue) x (cyan) ‚Üê (white) 5 (green) THEN (blue)</div>
                    </div>
                </div>

                <div class="keyword-section">
                    <h3>Mathematical Operators</h3>
                    
                    <div class="keyword-item">
                        <div class="keyword-syntax">Assignment vs Equality vs Power</div>
                        <div class="keyword-description">‚Üê for assignment, = for equality testing, ^ for exponentiation</div>
                        <div class="keyword-example">x ‚Üê 5 (assignment)<br>IF x = 5 THEN (equality)<br>area ‚Üê x ^ 2 (power)</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Arithmetic Operators</div>
                        <div class="keyword-description">+ (add), - (subtract), * (multiply), / (divide), ^ (power)</div>
                        <div class="keyword-example">result ‚Üê 2 + 3 * 4<br>area ‚Üê pi * radius ^ 2<br>compound ‚Üê principal * (1 + rate) ^ years</div>
                    </div>
                </div>

                <div class="keyword-section">
                    <h3>Control Structures</h3>
                    
                    <div class="keyword-item">
                        <div class="keyword-syntax">FOR variable ‚Üê start TO end DO<br>&nbsp;&nbsp;&nbsp;&nbsp;statements<br>END FOR</div>
                        <div class="keyword-description">Repeats statements with counter from start to end.</div>
                        <div class="keyword-example">FOR i ‚Üê 1 TO 5 DO<br>&nbsp;&nbsp;&nbsp;&nbsp;square ‚Üê i ^ 2<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT square<br>END FOR</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class MathematicalPseudocodeAnimator {
            constructor() {
                this.currentStep = -1;
                this.isRunning = false;
                this.autoRunning = false;
                this.variables = {};
                this.output = [];
                this.parsedCode = [];
                this.executionContext = { loopStacks: [], ifStack: [], breakpointPaused: false };
                this.autoRunSpeed = 5;
                this.breakpoints = new Set();
                this.executionHistory = [];
                this.stepCounter = 0;
                
                this.examples = {
                    simple: 'x ‚Üê 5\ny ‚Üê 10\nsum ‚Üê x + y\nPRINT "Sum: " + sum',
                    power: 'base ‚Üê 3\nexponent ‚Üê 4\nresult ‚Üê base ^ exponent\nPRINT base + " to the power of " + exponent + " = " + result',
                    squares: 'FOR i ‚Üê 1 TO 5 DO\n    square ‚Üê i ^ 2\n    PRINT "Square of " + i + " is " + square\nEND FOR',
                    loop: 'count ‚Üê 0\ntotal ‚Üê 0\nWHILE count < 5 DO\n    total ‚Üê total + count\n    count ‚Üê count + 1\nEND WHILE\nPRINT "Total: " + total',
                    factorial: 'n ‚Üê 5\nfactorial ‚Üê 1\ni ‚Üê 1\nWHILE i <= n DO\n    factorial ‚Üê factorial * i\n    i ‚Üê i + 1\nEND WHILE\nPRINT "Factorial of " + n + " is " + factorial',
                    logical: 'x ‚Üê 7\ny ‚Üê 3\nz ‚Üê 0\n\nIF x > 5 AND y < 10 THEN\n    PRINT "Both conditions met"\nEND IF\n\nIF x < 5 OR y < 5 THEN\n    PRINT "At least one is less than 5"\nEND IF\n\nIF (x > 0 AND y > 0) OR z = 0 THEN\n    PRINT "Complex condition is true"\nEND IF'
                };
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('parseBtn').addEventListener('click', () => this.parseCode());
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('nextBtn').addEventListener('click', () => this.nextStep());
                document.getElementById('prevBtn').addEventListener('click', () => this.stepBack());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('autoBtn').addEventListener('click', () => this.toggleAutoRun());
                document.getElementById('helpBtn').addEventListener('click', () => this.showHelp());
                
                const codeInput = document.getElementById('codeInput');
                codeInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const start = codeInput.selectionStart;
                        const end = codeInput.selectionEnd;
                        const value = codeInput.value;
                        codeInput.value = value.substring(0, start) + '    ' + value.substring(end);
                        codeInput.selectionStart = codeInput.selectionEnd = start + 4;
                    }
                });
                
                const modal = document.getElementById('helpModal');
                document.querySelector('.close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
                window.addEventListener('click', (e) => {
                    if (e.target === modal) modal.style.display = 'none';
                });
                
                document.querySelectorAll('.example-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const example = e.target.dataset.example;
                        document.getElementById('codeInput').value = this.examples[example];
                        this.parseCode();
                    });
                });

                const speedSlider = document.getElementById('speedSlider');
                speedSlider.addEventListener('input', (e) => {
                    this.autoRunSpeed = parseInt(e.target.value);
                    this.updateSpeedLabel();
                });
                this.updateSpeedLabel();
            }

            parseCode() {
                let rawInput = document.getElementById('codeInput').value;
                rawInput = rawInput.replace(/\^/g, '**');
                
                const lines = rawInput.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0)
                    .map(line => {
                        line = line.replace(/<-/g, '‚Üê');
                        // Normalize spacing around ‚Üê operator: ensure single space on both sides
                        line = line.replace(/\s*‚Üê\s*/g, ' ‚Üê ');
                        line = line.replace(/\b(if|then|else|elseif|end|while|do|for|to|output|print|input|and|or)\b/gi,
                            match => match.toUpperCase());
                        return line;
                    });

                const validation = this.validateCode(lines);
                const messageDiv = document.getElementById('validationMessage');
                
                if (validation.errors.length > 0) {
                    messageDiv.className = 'validation-message error';
                    messageDiv.style.display = 'block';
                    messageDiv.innerHTML = '<strong>Errors:</strong><br>' + validation.errors.join('<br>');
                    this.parsedCode = [];
                    this.renderParsedCode();
                    this.updateButtons();
                    return;
                }
                
                messageDiv.className = 'validation-message success';
                messageDiv.style.display = 'block';
                messageDiv.innerHTML = '<strong>‚úî Code parsed successfully!</strong>';
                
                this.parsedCode = lines;
                this.breakpoints.clear();
                this.executionHistory = [];
                this.stepCounter = 0;
                this.renderParsedCode();
                this.initializeVariables();
                this.updateButtons();
                this.updateDebugInfo();
                
                setTimeout(() => messageDiv.style.display = 'none', 3000);
            }

            validateCode(lines) {
                const errors = [];
                const blockStack = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const lineNum = i + 1;

                    if (line.includes('‚Üê') && !line.startsWith('IF ') && !line.startsWith('ELSE IF ') && 
                        !line.startsWith('WHILE ') && !line.startsWith('FOR ') && 
                        !line.startsWith('OUTPUT ') && !line.startsWith('PRINT ')) {
                        const parts = line.split('‚Üê');
                        if (parts.length !== 2 || parts[0].trim() === '' || parts[1].trim() === '') {
                            errors.push(`Line ${lineNum}: Invalid assignment format`);
                        }
                    } else if (line.startsWith('IF ')) {
                        if (!line.includes('THEN')) errors.push(`Line ${lineNum}: IF must end with THEN`);
                        blockStack.push('IF');
                    } else if (line.startsWith('WHILE ')) {
                        if (!line.includes('DO')) errors.push(`Line ${lineNum}: WHILE must end with DO`);
                        blockStack.push('WHILE');
                    } else if (line.startsWith('FOR ')) {
                        if (!line.includes('‚Üê') || !line.includes('TO') || !line.includes('DO')) {
                            errors.push(`Line ${lineNum}: FOR must be 'FOR var ‚Üê start TO end DO'`);
                        }
                        blockStack.push('FOR');
                    } else if (line.match(/^END (IF|WHILE|FOR)$/)) {
                        if (blockStack.length === 0) {
                            errors.push(`Line ${lineNum}: Unexpected END statement`);
                        } else {
                            blockStack.pop();
                        }
                    }
                }

                if (blockStack.length > 0) {
                    errors.push(`Missing END statements for: ${blockStack.join(', ')}`);
                }

                return { errors };
            }

            applySyntaxHighlighting(line, lineElement) {
                lineElement.innerHTML = '';
                const tokens = this.tokenizeLine(line);
                
                tokens.forEach(token => {
                    const span = document.createElement('span');
                    span.textContent = token.text;
                    span.className = token.type;
                    lineElement.appendChild(span);
                });
            }

            tokenizeLine(line) {
                const tokens = [];
                let i = 0;
                
                while (i < line.length) {
                    if (line[i] === ' ') {
                        let spaces = '';
                        while (i < line.length && line[i] === ' ') {
                            spaces += line[i];
                            i++;
                        }
                        tokens.push({ text: spaces, type: '' });
                        continue;
                    }
                    
                    if (line[i] === '"') {
                        let str = '"';
                        i++;
                        while (i < line.length && line[i] !== '"') {
                            str += line[i];
                            i++;
                        }
                        if (i < line.length) str += line[i++];
                        tokens.push({ text: str, type: 'string' });
                        continue;
                    }
                    
                    if (/\d/.test(line[i])) {
                        let num = '';
                        while (i < line.length && /[\d.]/.test(line[i])) {
                            num += line[i];
                            i++;
                        }
                        tokens.push({ text: num, type: 'number' });
                        continue;
                    }
                    
                    if (line[i] === '‚Üê') {
                        tokens.push({ text: '‚Üê', type: 'assignment' });
                        i++;
                        continue;
                    }
                    
                    if (line.substr(i, 2) === '**') {
                        tokens.push({ text: '**', type: 'operator' });
                        i += 2;
                        continue;
                    }
                    
                    if (/[+\-*/><=()]/.test(line[i])) {
                        if (i + 1 < line.length && line.substr(i, 2).match(/>=|<=/)) {
                            tokens.push({ text: line.substr(i, 2), type: 'operator' });
                            i += 2;
                        } else {
                            tokens.push({ text: line[i], type: 'operator' });
                            i++;
                        }
                        continue;
                    }
                    
                    if (/[a-zA-Z_]/.test(line[i])) {
                        let word = '';
                        while (i < line.length && /[a-zA-Z0-9_]/.test(line[i])) {
                            word += line[i];
                            i++;
                        }
                        
                        const keywords = ['IF', 'THEN', 'ELSE', 'ELSEIF', 'END', 'WHILE', 'DO', 'FOR', 'TO', 'OUTPUT', 'PRINT', 'INPUT', 'AND', 'OR'];
                        const type = keywords.includes(word) ? 'keyword' : 'variable';
                        tokens.push({ text: word, type });
                        continue;
                    }
                    
                    tokens.push({ text: line[i], type: '' });
                    i++;
                }
                
                return tokens;
            }

            renderParsedCode() {
                const pseudocodeDiv = document.getElementById('pseudocode');
                if (this.parsedCode.length === 0) {
                    pseudocodeDiv.innerHTML = '<div style="color: #999; font-style: italic; padding: 20px;">No valid code to display</div>';
                    return;
                }
                
                let indentLevel = 0;
                pseudocodeDiv.innerHTML = '';
                
                this.parsedCode.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    
                    if (trimmedLine.startsWith('END ') || 
                        trimmedLine === 'ELSE' || 
                        trimmedLine.startsWith('ELSE IF ')) {
                        indentLevel = Math.max(0, indentLevel - 1);
                    }
                    
                    const indent = '    '.repeat(indentLevel);
                    const indentedLine = indent + trimmedLine;
                    
                    if (trimmedLine.startsWith('IF ') || 
                        trimmedLine.startsWith('ELSE IF ') ||
                        trimmedLine === 'ELSE' ||
                        trimmedLine.startsWith('WHILE ') || 
                        trimmedLine.startsWith('FOR ')) {
                        indentLevel++;
                    }
                    
                    const isBreakpoint = this.breakpoints.has(index);
                    
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'pseudocode-line';
                    lineDiv.dataset.line = index;
                    
                    const lineNumDiv = document.createElement('div');
                    lineNumDiv.className = `line-number ${isBreakpoint ? 'breakpoint' : ''}`;
                    lineNumDiv.dataset.line = index;
                    lineNumDiv.textContent = index + 1;
                    lineNumDiv.addEventListener('click', (e) => {
                        const lineIndex = parseInt(e.target.dataset.line);
                        this.toggleBreakpoint(lineIndex);
                    });
                    
                    const lineContentDiv = document.createElement('div');
                    lineContentDiv.className = 'line-content';
                    
                    this.applySyntaxHighlighting(indentedLine, lineContentDiv);
                    
                    lineDiv.appendChild(lineNumDiv);
                    lineDiv.appendChild(lineContentDiv);
                    pseudocodeDiv.appendChild(lineDiv);
                });
            }

            toggleBreakpoint(lineIndex) {
                if (this.breakpoints.has(lineIndex)) {
                    this.breakpoints.delete(lineIndex);
                } else {
                    this.breakpoints.add(lineIndex);
                }
                this.renderParsedCode();
                this.updateDebugInfo();
            }

            saveExecutionState() {
                this.executionHistory.push({
                    step: this.currentStep,
                    variables: JSON.parse(JSON.stringify(this.variables)),
                    output: [...this.output],
                    executionContext: JSON.parse(JSON.stringify(this.executionContext)),
                    stepCounter: this.stepCounter
                });
            }

            stepBack() {
                if (this.executionHistory.length === 0) return;
                
                const previousState = this.executionHistory.pop();
                this.currentStep = previousState.step;
                this.variables = previousState.variables;
                this.output = previousState.output;
                this.executionContext = previousState.executionContext;
                this.stepCounter = previousState.stepCounter;
                
                this.renderVariables();
                this.renderOutput();
                this.highlightLine(this.currentStep);
                this.updateButtons();
                this.updateDebugInfo();
            }

            initializeVariables() {
                this.variables = {};
                this.renderVariables();
                this.clearOutput();
            }

            renderVariables() {
                const variablesDiv = document.getElementById('variables');
                if (Object.keys(this.variables).length === 0) {
                    variablesDiv.innerHTML = '<div style="color: #999; font-style: italic;">No variables defined yet</div>';
                    return;
                }
                
                variablesDiv.innerHTML = Object.entries(this.variables).map(([name, value]) => 
                    `<div class="variable-item" data-var="${name}">
                        <span class="variable-name">${name}:</span>
                        <span class="variable-value">${this.formatValue(value)}</span>
                    </div>`
                ).join('');
            }

            formatValue(value) {
                if (Array.isArray(value)) return `[${value.join(', ')}]`;
                if (typeof value === 'string') return `"${value}"`;
                return String(value);
            }

            updateVariable(name, value, highlight = true) {
                this.variables[name] = value;
                this.renderVariables();
                if (highlight) {
                    const varItem = document.querySelector(`[data-var="${name}"]`);
                    if (varItem) {
                        varItem.classList.add('updated');
                        setTimeout(() => varItem.classList.remove('updated'), 1000);
                    }
                }
            }

            evaluateExpression(expr) {
                expr = expr.trim();
                
                if (expr.includes('+') && (expr.includes('"') || expr.includes("'"))) {
                    return this.evaluateStringExpression(expr);
                }
                
                if (expr.includes('[') && expr.includes(']')) {
                    const match = expr.match(/(\w+)\[(.+)\]/);
                    if (match) {
                        const arrayName = match[1];
                        const indexExpr = match[2];
                        const index = this.evaluateExpression(indexExpr);
                        return this.variables[arrayName] ? this.variables[arrayName][index] : undefined;
                    }
                }
                
                if (/^\w+$/.test(expr) && this.variables.hasOwnProperty(expr)) {
                    return this.variables[expr];
                }
                
                if (/^-?\d+(\.\d+)?$/.test(expr)) {
                    return parseFloat(expr);
                }
                
                if ((expr.startsWith('"') && expr.endsWith('"')) || 
                    (expr.startsWith("'") && expr.endsWith("'"))) {
                    return expr.slice(1, -1);
                }
                
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const content = expr.slice(1, -1).trim();
                    if (content === '') return [];
                    return content.split(',').map(item => this.evaluateExpression(item.trim()));
                }
                
                return this.evaluateArithmetic(expr);
            }

            evaluateStringExpression(expr) {
                const parts = expr.split('+');
                let result = '';
                for (const part of parts) {
                    const value = this.evaluateExpression(part.trim());
                    result += String(value);
                }
                return result;
            }

            evaluateArithmetic(expr) {
                let processedExpr = expr;
                
                const sortedVars = Object.keys(this.variables).sort((a, b) => b.length - a.length);
                for (const name of sortedVars) {
                    const value = this.variables[name];
                    if (typeof value === 'number') {
                        processedExpr = processedExpr.replace(new RegExp(`\\b${name}\\b`, 'g'), `(${value})`);
                    }
                }
                
                try {
                    return Function(`"use strict"; return (${processedExpr})`)();
                } catch (e) {
                    console.log('Arithmetic error:', e, 'Expression:', processedExpr);
                    return 0;
                }
            }

            evaluateCondition(condition) {
                condition = condition.trim();
                condition = condition.replace(/‚â•/g, '>=').replace(/‚â§/g, '<=');
                
                // Handle parentheses recursively
                while (condition.includes('(')) {
                    condition = condition.replace(/\([^()]+\)/g, (match) => {
                        const inner = match.slice(1, -1);
                        return this.evaluateCondition(inner) ? 'TRUE' : 'FALSE';
                    });
                }
                
                // Handle OR operator (lower precedence)
                if (condition.includes(' OR ')) {
                    const parts = condition.split(' OR ');
                    for (const part of parts) {
                        if (this.evaluateCondition(part.trim())) {
                            return true;
                        }
                    }
                    return false;
                }
                
                // Handle AND operator (higher precedence)
                if (condition.includes(' AND ')) {
                    const parts = condition.split(' AND ');
                    for (const part of parts) {
                        if (!this.evaluateCondition(part.trim())) {
                            return false;
                        }
                    }
                    return true;
                }
                
                // Handle boolean literals from parentheses evaluation
                if (condition === 'TRUE') return true;
                if (condition === 'FALSE') return false;
                
                // Handle simple comparisons
                const operators = ['>=', '<=', '>', '<', '='];
                for (const op of operators) {
                    if (condition.includes(op)) {
                        const parts = condition.split(op);
                        if (parts.length === 2) {
                            const leftVal = this.evaluateExpression(parts[0].trim());
                            const rightVal = this.evaluateExpression(parts[1].trim());
                            
                            switch (op) {
                                case '>=': return leftVal >= rightVal;
                                case '<=': return leftVal <= rightVal;
                                case '>': return leftVal > rightVal;
                                case '<': return leftVal < rightVal;
                                case '=': return leftVal == rightVal;
                            }
                        }
                    }
                }
                return false;
            }

            highlightLine(lineIndex) {
                document.querySelectorAll('.pseudocode-line').forEach((line, index) => {
                    line.classList.remove('current', 'completed', 'error');
                    if (index < lineIndex) {
                        line.classList.add('completed');
                    } else if (index === lineIndex) {
                        line.classList.add('current');
                    }
                });
            }

            addOutput(text) {
                this.output.push(text);
                this.renderOutput();
            }

            renderOutput() {
                document.getElementById('output').innerHTML = this.output.join('<br>');
            }

            clearOutput() {
                this.output = [];
                this.renderOutput();
            }

            start() {
                if (this.parsedCode.length === 0) {
                    alert('Please parse your code first!');
                    return;
                }
                
                this.isRunning = true;
                this.currentStep = -1;
                this.stepCounter = 0;
                this.executionContext = { loopStacks: [], ifStack: [], breakpointPaused: false };
                this.executionHistory = [];
                this.initializeVariables();
                this.updateButtons();
                this.updateDebugInfo();
                this.nextStep();
            }

            reset() {
                this.isRunning = false;
                this.autoRunning = false;
                this.currentStep = -1;
                this.stepCounter = 0;
                this.executionContext = { loopStacks: [], ifStack: [], breakpointPaused: false };
                this.executionHistory = [];
                this.initializeVariables();
                this.updateButtons();
                this.updateDebugInfo();
                document.querySelectorAll('.pseudocode-line').forEach(line => {
                    line.classList.remove('current', 'completed', 'error');
                });
            }

            toggleAutoRun() {
                if (this.autoRunning) {
                    this.autoRunning = false;
                    this.updateButtons();
                } else {
                    if (!this.isRunning) {
                        this.start();
                    }
                    this.autoRunning = true;
                    this.updateButtons();
                    this.autoExecute();
                }
            }

            autoExecute() {
                if (this.autoRunning && this.isRunning) {
                    this.nextStep();
                    if (this.isRunning) {
                        const delay = 3100 - (this.autoRunSpeed * 300);
                        setTimeout(() => this.autoExecute(), delay);
                    }
                }
            }

            nextStep() {
                if (!this.isRunning) return;

                this.currentStep++;
                
                if (this.currentStep >= this.parsedCode.length) {
                    this.isRunning = false;
                    this.autoRunning = false;
                    this.updateButtons();
                    this.updateDebugInfo();
                    return;
                }

                // Check for breakpoint BEFORE executing
                if (this.breakpoints.has(this.currentStep) && !this.executionContext.breakpointPaused) {
                    this.executionContext.breakpointPaused = true;
                    this.highlightLine(this.currentStep);
                    
                    if (this.autoRunning) {
                        this.autoRunning = false;
                    }
                    
                    this.updateButtons();
                    this.updateDebugInfo();
                    return;
                }

                this.executionContext.breakpointPaused = false;

                this.saveExecutionState();
                this.stepCounter++;

                this.highlightLine(this.currentStep);
                this.executeStep(this.parsedCode[this.currentStep]);

                // Check if next line is END FOR/END WHILE and we need to continue loop
                this.checkLoopContinuation();

                this.updateButtons();
                this.updateDebugInfo();
            }

            checkLoopContinuation() {
                // Check if the next line is END FOR or END WHILE
                const nextLineIndex = this.currentStep + 1;
                if (nextLineIndex >= this.parsedCode.length) return;

                const nextLine = this.parsedCode[nextLineIndex];

                if (nextLine === 'END FOR') {
                    const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                    if (loop && loop.type === 'FOR') {
                        const currentVal = this.variables[loop.varName];
                        if (currentVal < loop.endVal) {
                            // Continue loop: increment and jump back to FOR line
                            this.updateVariable(loop.varName, currentVal + 1);
                            this.currentStep = loop.startLine - 1; // -1 because nextStep() will increment
                            return;
                        }
                    }
                } else if (nextLine === 'END WHILE') {
                    const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                    if (loop && loop.type === 'WHILE') {
                        const result = this.evaluateCondition(loop.condition);
                        if (result) {
                            // Continue loop: jump back to WHILE line
                            this.currentStep = loop.startLine - 1; // -1 because nextStep() will increment
                            return;
                        }
                    }
                }
            }

            executeStep(line) {
                try {
                    if (line.includes('‚Üê') && !line.startsWith('IF ') && !line.startsWith('ELSE IF ') && 
                        !line.startsWith('WHILE ') && !line.startsWith('FOR ') && 
                        !line.startsWith('OUTPUT ') && !line.startsWith('PRINT ')) {
                        
                        const parts = line.split('‚Üê');
                        if (parts.length === 2) {
                            const varName = parts[0].trim();
                            const value = this.evaluateExpression(parts[1].trim());
                            this.updateVariable(varName, value);
                        }
                    } else if (line.startsWith('OUTPUT ')) {
                        const expr = line.substring(7);
                        const value = this.evaluateExpression(expr);
                        this.addOutput(String(value));
                    } else if (line.startsWith('PRINT ')) {
                        const expr = line.substring(6);
                        const value = this.evaluateExpression(expr);
                        this.addOutput(String(value));
                    } else if (line.startsWith('IF ')) {
                        const thenIndex = line.indexOf('THEN');
                        if (thenIndex > 0) {
                            const condition = line.substring(3, thenIndex).trim();
                            const result = this.evaluateCondition(condition);
                            
                            this.executionContext.ifStack.push({
                                startLine: this.currentStep,
                                conditionMet: result,
                                hasExecuted: result
                            });
                            
                            if (!result) {
                                this.skipToNextIfBlock();
                            }
                        }
                    } else if (line.startsWith('ELSE IF ')) {
                        const currentIf = this.executionContext.ifStack[this.executionContext.ifStack.length - 1];
                        if (currentIf && !currentIf.hasExecuted) {
                            const thenIndex = line.indexOf('THEN');
                            if (thenIndex > 0) {
                                const condition = line.substring(8, thenIndex).trim();
                                const result = this.evaluateCondition(condition);
                                
                                if (result) {
                                    currentIf.hasExecuted = true;
                                    currentIf.conditionMet = true;
                                } else {
                                    this.skipToNextIfBlock();
                                }
                            }
                        } else {
                            this.skipToEndIf();
                        }
                    } else if (line === 'ELSE') {
                        const currentIf = this.executionContext.ifStack[this.executionContext.ifStack.length - 1];
                        if (currentIf && currentIf.hasExecuted) {
                            this.skipToEndIf();
                        }
                    } else if (line === 'END IF') {
                        this.executionContext.ifStack.pop();
                    } else if (line.startsWith('WHILE ')) {
                        const doIndex = line.indexOf('DO');
                        if (doIndex > 0) {
                            const condition = line.substring(6, doIndex).trim();
                            const result = this.evaluateCondition(condition);
                            if (result) {
                                this.executionContext.loopStacks.push({
                                    type: 'WHILE',
                                    startLine: this.currentStep,
                                    condition: condition
                                });
                            } else {
                                this.skipToEnd('WHILE');
                            }
                        }
                    } else if (line === 'END WHILE') {
                        // Only reached when loop actually ends (checkLoopContinuation handles continuation)
                        const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                        if (loop && loop.type === 'WHILE') {
                            this.executionContext.loopStacks.pop();
                        }
                    } else if (line.startsWith('FOR ')) {
                        const match = line.match(/FOR (\w+) ‚Üê (.+) TO (.+) DO/);
                        if (match) {
                            const varName = match[1];
                            const startVal = this.evaluateExpression(match[2]);
                            const endVal = this.evaluateExpression(match[3]);
                            
                            if (!this.executionContext.loopStacks.find(loop => loop.type === 'FOR' && loop.varName === varName)) {
                                this.updateVariable(varName, startVal);
                            }
                            
                            if (this.variables[varName] <= endVal) {
                                this.executionContext.loopStacks.push({
                                    type: 'FOR',
                                    startLine: this.currentStep,
                                    varName: varName,
                                    endVal: endVal
                                });
                            } else {
                                this.skipToEnd('FOR');
                            }
                        }
                    } else if (line === 'END FOR') {
                        // Only reached when loop actually ends (checkLoopContinuation handles continuation)
                        const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                        if (loop && loop.type === 'FOR') {
                            this.executionContext.loopStacks.pop();
                        }
                    }
                } catch (error) {
                    this.addOutput(`Error: ${error.message}`);
                    const currentLine = document.querySelector(`[data-line="${this.currentStep}"]`);
                    if (currentLine) {
                        currentLine.classList.add('error');
                    }
                }
            }

            skipToNextIfBlock() {
                let depth = 0;
                while (this.currentStep + 1 < this.parsedCode.length) {
                    this.currentStep++;
                    const line = this.parsedCode[this.currentStep];
                    
                    if (line.startsWith('IF ')) {
                        depth++;
                    } else if (line === 'END IF') {
                        if (depth === 0) {
                            this.currentStep--;
                            return;
                        }
                        depth--;
                    } else if (depth === 0 && (line.startsWith('ELSE IF ') || line === 'ELSE')) {
                        this.currentStep--;
                        return;
                    }
                }
            }

            skipToEndIf() {
                let depth = 0;
                while (this.currentStep + 1 < this.parsedCode.length) {
                    this.currentStep++;
                    const line = this.parsedCode[this.currentStep];
                    
                    if (line.startsWith('IF ')) {
                        depth++;
                    } else if (line === 'END IF') {
                        if (depth === 0) {
                            this.currentStep--;
                            return;
                        }
                        depth--;
                    }
                }
            }

            skipToEnd(blockType) {
                let depth = 1;
                while (this.currentStep + 1 < this.parsedCode.length && depth > 0) {
                    this.currentStep++;
                    const line = this.parsedCode[this.currentStep];
                    
                    if (line.startsWith(blockType + ' ') || 
                        (blockType === 'IF' && line.startsWith('IF ')) ||
                        (blockType === 'WHILE' && line.startsWith('WHILE ')) ||
                        (blockType === 'FOR' && line.startsWith('FOR '))) {
                        depth++;
                    } else if (line === `END ${blockType}`) {
                        depth--;
                    }
                }
            }

            showHelp() {
                document.getElementById('helpModal').style.display = 'block';
            }

            updateButtons() {
                const startBtn = document.getElementById('startBtn');
                const nextBtn = document.getElementById('nextBtn');
                const prevBtn = document.getElementById('prevBtn');
                const autoBtn = document.getElementById('autoBtn');

                startBtn.disabled = this.parsedCode.length === 0 || this.isRunning;
                nextBtn.disabled = !this.isRunning || this.autoRunning;
                prevBtn.disabled = !this.isRunning || this.executionHistory.length === 0;
                autoBtn.disabled = this.parsedCode.length === 0;
                autoBtn.textContent = this.autoRunning ? 'Pause Auto' : 'Auto Run';
            }

            updateDebugInfo() {
                document.getElementById('stepCounter').textContent = this.stepCounter;
                document.getElementById('breakpointCount').textContent = this.breakpoints.size;
                
                let status = 'Ready';
                if (this.isRunning) {
                    if (this.autoRunning) {
                        status = 'Auto Running';
                    } else if (this.breakpoints.has(this.currentStep)) {
                        status = 'Paused at Breakpoint';
                    } else {
                        status = 'Running (Manual)';
                    }
                } else if (this.currentStep >= this.parsedCode.length - 1 && this.stepCounter > 0) {
                    status = 'Completed';
                }
                
                document.getElementById('executionStatus').textContent = status;
            }

            updateSpeedLabel() {
                const speedLabel = document.getElementById('speedLabel');
                const speedNames = {
                    1: 'Very Slow',
                    2: 'Slow',
                    3: 'Slow',
                    4: 'Medium',
                    5: 'Normal',
                    6: 'Normal',
                    7: 'Fast',
                    8: 'Fast',
                    9: 'Very Fast',
                    10: 'Maximum'
                };
                speedLabel.textContent = speedNames[this.autoRunSpeed] || 'Normal';
            }
        }

        // Initialize the animator when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            new MathematicalPseudocodeAnimator();
        });
    </script>
</body>
</html>