<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maths Pseudocode Animator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            margin: 0;
            box-sizing: border-box;
        }

        .container {
            display: flex;
            height: 100vh;
            max-width: none;
            margin: 0;
            background: white;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin: 20px 0;
        }

        .speed-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .speed-control label {
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
        }

        .speed-select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
        }

        .speed-select:focus {
            border-color: #3498db;
            background: white;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        .speed-select:hover {
            background: white;
            border-color: rgba(255, 255, 255, 0.5);
        }

        #speedLabel {
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            min-width: 90px;
            text-align: center;
            padding: 10px 18px;
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            border-radius: 25px;
            box-shadow: 0 3px 10px rgba(116, 185, 255, 0.3);
        }

        .sidebar {
            width: 280px;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .main-content {
            display: flex;
            flex: 1;
            height: 100vh;
            overflow: hidden;
        }

        .left-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #dee2e6;
        }

        .right-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
        }

        .content {
            display: none; /* Hide old content structure */
        }

        .input-panel, .pseudocode-panel, .variables-panel {
            background: #f8f9fa;
            border-radius: 0;
            border: none;
            padding: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            margin: 0;
        }

        .input-panel {
            flex: 1;
            border-bottom: 1px solid #dee2e6;
        }

        .variables-panel {
            height: 300px;
            border-top: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .pseudocode-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .output-panel {
            height: 250px;
            background: #2c3e50;
            border-top: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .panel-title-fixed {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding: 15px 20px 10px 20px;
            background: #f8f9fa;
            flex-shrink: 0;
            margin: 0;
        }

        .output-panel .panel-title-fixed {
            background: #34495e;
            color: #ecf0f1;
            border-bottom-color: #3498db;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }

        .output-panel .panel-content {
            background: #2c3e50;
            color: #ecf0f1;
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .variables-content {
            background: #f8f9fa;
        }

        .code-input {
            width: 100%;
            height: 400px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            resize: vertical;
            background: #fff;
            line-height: 1.5;
        }

        .code-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.2);
        }

        .validation-message {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
        }

        .validation-message.error {
            background: #fee;
            border: 1px solid #fcc;
            color: #c33;
        }

        .validation-message.success {
            background: #efe;
            border: 1px solid #cfc;
            color: #3c3;
        }

        .validation-message.warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .pseudocode-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 0;
            flex: 1;
            overflow-y: auto;
            border: 2px solid #333;
            min-height: 0;
        }

        .pseudocode-line {
            display: flex;
            align-items: center;
            margin: 0;
            transition: all 0.3s ease;
            font-size: 14px;
            line-height: 1.4;
            min-height: 28px;
            border-left: 4px solid transparent;
        }

        .line-number {
            min-width: 40px;
            padding: 6px 8px;
            background: #2d2d2d;
            color: #858585;
            text-align: right;
            font-size: 12px;
            border-right: 1px solid #444;
            cursor: pointer;
            user-select: none;
        }

        .line-number:hover {
            background: #3d3d3d;
            color: #fff;
        }

        .line-number.breakpoint {
            background: #e74c3c;
            color: white;
        }

        .line-number.breakpoint::before {
            content: "‚óè";
            margin-right: 4px;
        }

        .line-content {
            flex: 1;
            padding: 6px 12px;
            background: #1e1e1e;
            color: #d4d4d4;
            white-space: pre;
        }

        .pseudocode-line.current {
            background: #2d4f3e;
            border-left-color: #fdcb6e;
        }

        .pseudocode-line.current .line-content {
            background: #2d4f3e;
        }

        .pseudocode-line.current .line-number {
            background: #fdcb6e;
            color: #2c3e50;
            font-weight: bold;
        }

        .pseudocode-line.completed {
            opacity: 0.6;
        }

        .pseudocode-line.completed .line-content {
            background: #1a3d2e;
        }

        .pseudocode-line.error {
            background: #4a2c2c;
            border-left-color: #e74c3c;
        }

        .pseudocode-line.error .line-content {
            background: #4a2c2c;
        }

        /* Syntax Highlighting */
        .keyword { color: #569cd6; font-weight: bold; }
        .string { color: #ce9178; }
        .number { color: #b5cea8; }
        .operator { color: #dcdcaa; }
        .variable { color: #9cdcfe; }
        .assignment { color: #d4d4d4; font-weight: bold; }
        .comment { color: #6a9955; font-style: italic; }

        .variable-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: white;
            border-radius: 8px;
            border: 2px solid #ddd;
            transition: all 0.3s ease;
        }

        .variable-item.updated {
            border-color: #e17055;
            background: #ffeaa7;
            transform: scale(1.02);
            box-shadow: 0 3px 10px rgba(225, 112, 85, 0.2);
        }

        .variable-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .variable-value {
            font-weight: bold;
            color: #e17055;
            font-size: 1.1rem;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(116, 185, 255, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7);
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(162, 155, 254, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894, #00a085);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.4);
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
        }

        .btn-info:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(23, 162, 184, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .output {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Consolas', monospace;
            min-height: 60px;
            border: 2px solid #4a5568;
        }

        .output-title {
            color: #81c784;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .examples {
            margin-top: 15px;
        }

        .example-dropdown {
            padding: 8px 12px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            min-width: 200px;
            transition: all 0.2s ease;
        }

        .example-dropdown:hover {
            background: #bbdefb;
        }

        .example-dropdown:focus {
            outline: none;
            border-color: #42a5f5;
            box-shadow: 0 0 5px rgba(66, 165, 245, 0.3);
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
        }

        .debug-info {
            background: #2c3e50;
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
        }

        .step-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 15px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        .modal-header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            margin: -20px -20px 20px -20px;
            padding: 20px;
            border-radius: 15px 15px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .close {
            color: white;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            opacity: 0.7;
        }

        .keyword-section {
            margin-bottom: 25px;
        }

        .keyword-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .keyword-item {
            background: #f8f9fa;
            margin: 8px 0;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .keyword-syntax {
            font-family: 'Consolas', monospace;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .keyword-description {
            color: #666;
            font-size: 14px;
        }

        .keyword-example {
            font-family: 'Consolas', monospace;
            background: #e8f4f8;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 13px;
            border: 1px solid #d4e6ea;
        }

        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 200px;
            }

            .speed-control {
                flex-direction: column;
                gap: 10px;
            }

            .speed-select {
                width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="header">
                <h1>Maths Pseudocode Animator</h1>
                <p>Write mathematically correct pseudocode and watch it execute step by step</p>
            </div>

            <div class="examples">
                <label for="exampleSelect" style="font-weight: bold; margin-right: 8px; color: white;">Quick Examples:</label>
                <select id="exampleSelect" class="example-dropdown">
                    <option value="">-- Select an example --</option>
                    <option value="simple">Simple Calculation</option>
                    <option value="power">Powers & Exponents</option>
                    <option value="loop">While Loop</option>
                    <option value="factorial">Factorial</option>
                    <option value="squares">Square Numbers</option>
                    <option value="logical">Logical Operators (AND/OR)</option>
                    <option value="functions">Functions</option>
                    <option value="methods">Methods</option>
                    <option value="steps">FOR Loops with Steps</option>
                    <option value="factors">Factors</option>
                    <option value="bubblesort">Bubble Sort</option>
                    <option value="bisection">Bisection Method</option>
                    <option value="newton">Newton's Method</option>
                    <option value="euler">Euler's Method</option>
                </select>
            </div>

            <div class="controls">
                <button class="btn btn-primary" id="startBtn" disabled>Parse & Start</button>
                <button class="btn btn-primary" id="nextBtn" disabled>Next Step</button>
                <button class="btn btn-warning" id="prevBtn" disabled>Step Back</button>
                <button class="btn btn-primary" id="autoBtn" disabled>Auto Run</button>
                <button class="btn btn-secondary" id="resetBtn">Reset</button>
                <button class="btn btn-info" id="helpBtn">üìñ Help & Keywords</button>
            </div>

            <div class="speed-control">
                <label for="speedSelect">Auto Run Speed:</label>
                <select id="speedSelect" class="speed-select">
                    <option value="1">Very Slow</option>
                    <option value="3">Slow</option>
                    <option value="5" selected>Normal</option>
                    <option value="7">Fast</option>
                    <option value="12">Very Fast</option>
                </select>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Left Panel: Input Panel (top) + Variables Panel (bottom) -->
            <div class="left-panel">
                <div class="input-panel">
                    <div class="panel-title">Write Your Pseudocode</div>
                    <textarea id="codeInput" class="code-input" placeholder="Enter your pseudocode here...

Example with new structure:
BEGIN
    x ‚Üê 5
    y ‚Üê 10
    sum ‚Üê x + y
    square ‚Üê x ^ 2
    OUTPUT sum
    OUTPUT square
END

Supported commands:
‚Ä¢ BEGIN ... END (main program)
‚Ä¢ FUNCTION name ... END FUNCTION
‚Ä¢ METHOD name ... END METHOD
‚Ä¢ variable ‚Üê value
‚Ä¢ PRINT variable/value
‚Ä¢ OUTPUT variable/value
‚Ä¢ IF condition THEN ... END IF
‚Ä¢ WHILE condition DO ... END WHILE
‚Ä¢ FOR variable ‚Üê start TO end [STEP increment] DO ... END FOR

Boolean logic:
‚Ä¢ AND, OR for combining conditions
‚Ä¢ Use parentheses for grouping: (x > 5 AND y < 10) OR z = 0

Use ‚Üê for assignment, = for equality, ^ for powers
Click line numbers to set breakpoints!"></textarea>
                    <div id="validationMessage" class="validation-message"></div>

                    <div class="help-text">
                        <strong>Instructions:</strong> Click line numbers to set breakpoints. Use Step Back to undo steps.
                        Syntax highlighting shows different code elements in color.
                    </div>
                </div>

                <div class="output-panel">
                    <div class="panel-title-fixed">Output</div>
                    <div class="panel-content" id="output"></div>
                </div>

                <div class="variables-panel">
                    <div class="panel-title-fixed">Variables</div>
                    <div class="panel-content variables-content" id="variables"></div>
                </div>
            </div>

            <!-- Right Panel: Pseudocode Panel -->
            <div class="right-panel">
                <div class="pseudocode-panel">
                    <div class="panel-title">Processed Code</div>
                    <div class="pseudocode-container" id="pseudocode"></div>

                    <div class="debug-info">
                        <div class="step-info">
                            <span>Step: <span id="stepCounter">0</span></span>
                            <span>Breakpoints: <span id="breakpointCount">0</span></span>
                        </div>
                        <div>Status: <span id="executionStatus">Ready</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hidden old content structure for compatibility -->
        <div class="content">
            <div class="input-panel">
                <div class="panel-title">Write Your Pseudocode</div>
                <textarea id="codeInput" class="code-input"></textarea>
                <div id="validationMessage" class="validation-message"></div>

                <div class="examples">
                    <label for="exampleSelect" style="font-weight: bold; margin-right: 8px; color: #2c3e50;">Quick Examples:</label>
                    <select id="exampleSelect" class="example-dropdown">
                        <option value="">-- Select an example --</option>
                        <option value="simple">Simple Calculation</option>
                        <option value="power">Powers & Exponents</option>
                        <option value="loop">While Loop</option>
                        <option value="factorial">Factorial</option>
                        <option value="squares">Square Numbers</option>
                        <option value="logical">Logical Operators (AND/OR)</option>
                        <option value="functions">Functions</option>
                        <option value="methods">Methods</option>
                        <option value="steps">FOR Loops with Steps</option>
                        <option value="factors">Factors</option>
                        <option value="bubblesort">Bubble Sort</option>
                        <option value="bisection">Bisection Method</option>
                        <option value="newton">Newton's Method</option>
                        <option value="euler">Euler's Method</option>
                    </select>
                </div>

                <div class="help-text">
                    <strong>Instructions:</strong> Click line numbers to set breakpoints. Use Step Back to undo steps.
                    Syntax highlighting shows different code elements in color.
                </div>
            </div>

            <div class="pseudocode-panel">
                <div class="panel-title">Processed Code</div>
                <div class="pseudocode-container" id="pseudocode"></div>

                <div class="debug-info">
                    <div class="step-info">
                        <span>Step: <span id="stepCounter">0</span></span>
                        <span>Breakpoints: <span id="breakpointCount">0</span></span>
                    </div>
                    <div>Status: <span id="executionStatus">Ready</span></div>
                </div>

                <div class="output">
                    <div class="output-title">Output:</div>
                    <div id="output"></div>
                </div>
            </div>

            <div class="variables-panel">
                <div class="panel-title">Variables</div>
                <div id="variables"></div>
            </div>
        </div>

        <!-- Help Modal -->
        <div id="helpModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <span class="close">&times;</span>
                    <h2>Maths Pseudocode Animator - User Guide</h2>
                </div>

                <div class="keyword-section">
                    <h3>Getting Started</h3>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Basic Usage</div>
                        <div class="keyword-description">Write your pseudocode in the editor, then click "Parse & Start" to begin execution. Use the Examples dropdown for pre-built algorithms.</div>
                        <div class="keyword-example">1. Select example or write code<br>2. Click "Parse & Start"<br>3. Use "Next Step" to execute line by line</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Code Structure</div>
                        <div class="keyword-description">All programs start with BEGIN and end with END. Functions and methods are defined before the main program.</div>
                        <div class="keyword-example">FUNCTION name(params)<br>&nbsp;&nbsp;&nbsp;&nbsp;statements<br>END FUNCTION<br><br>BEGIN<br>&nbsp;&nbsp;&nbsp;&nbsp;main program<br>END</div>
                    </div>
                </div>

                <div class="keyword-section">
                    <h3>Control Flow</h3>

                    <div class="keyword-item">
                        <div class="keyword-syntax">IF/ELSE Statements</div>
                        <div class="keyword-description">Conditional execution with support for boolean logic (AND, OR) and nested conditions. Use parentheses for complex logic.</div>
                        <div class="keyword-example">IF x > 5 THEN<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT "Greater"<br>ELSE<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT "Smaller"<br>END IF<br><br>IF x > 5 AND y < 10 THEN<br>IF (a = 1 OR b = 2) AND c > 0 THEN</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">WHILE Loops</div>
                        <div class="keyword-description">Repeat statements while a condition is true. Useful for iterative algorithms and convergence.</div>
                        <div class="keyword-example">WHILE count < 10 DO<br>&nbsp;&nbsp;&nbsp;&nbsp;count ‚Üê count + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT count<br>END WHILE</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">FOR Loops with STEP</div>
                        <div class="keyword-description">Count from start to end with optional step size. Use negative step to count backwards. Perfect for sequences and iterations.</div>
                        <div class="keyword-example">FOR i ‚Üê 1 TO 10 STEP 2 DO<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT i<br>END FOR<br><br>FOR i ‚Üê 10 TO 1 STEP -1 DO<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT "Countdown: " + i<br>END FOR</div>
                    </div>
                </div>

                <div class="keyword-section">
                    <h3>Functions & Methods</h3>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Functions</div>
                        <div class="keyword-description">Functions return values using RETURN statement. They can accept parameters and perform calculations.</div>
                        <div class="keyword-example">FUNCTION square(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;result ‚Üê x * x<br>&nbsp;&nbsp;&nbsp;&nbsp;RETURN result<br>END FUNCTION<br><br>area ‚Üê square(5)</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Methods</div>
                        <div class="keyword-description">Methods perform actions without returning values. They can output results or modify global state.</div>
                        <div class="keyword-example">METHOD printInfo(name, age)<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT "Name: " + name<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT "Age: " + age<br>END METHOD<br><br>printInfo("Alice", 25)</div>
                    </div>
                </div>

                <div class="keyword-section">
                    <h3>Mathematical Operations</h3>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Assignment vs Equality</div>
                        <div class="keyword-description">Use ‚Üê for assignment (storing values) and = for equality testing (comparisons in conditions).</div>
                        <div class="keyword-example">x ‚Üê 5 (assigns 5 to x)<br>IF x = 5 THEN (tests if x equals 5)<br>y ‚Üê x + 3 (assigns x+3 to y)</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Arithmetic Operators</div>
                        <div class="keyword-description">Standard mathematical operations with proper precedence. Use ^ for exponentiation.</div>
                        <div class="keyword-example">Basic: + - * /<br>Power: x ^ 2 (x squared)<br>Complex: result ‚Üê (a + b) * c ^ 2<br>Scientific: compound ‚Üê principal * (1 + rate) ^ years</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Comparison Operators</div>
                        <div class="keyword-description">Use for conditions in IF statements and WHILE loops. Support mathematical comparisons.</div>
                        <div class="keyword-example">> (greater than)<br>< (less than)<br>>= (greater or equal)<br><= (less or equal)<br>= (equal to)</div>
                    </div>
                </div>

                <div class="keyword-section">
                    <h3>Execution Controls</h3>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Step Through Execution</div>
                        <div class="keyword-description">Execute one line at a time to understand algorithm flow. Watch variables change in the Variables panel.</div>
                        <div class="keyword-example">"Next Step" - Execute current line<br>"Step Back" - Undo last execution<br>"Auto Run" - Continuous execution<br>"Reset" - Start over</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Breakpoints</div>
                        <div class="keyword-description">Click on line numbers to set breakpoints. Execution pauses BEFORE the breakpoint line during Auto Run.</div>
                        <div class="keyword-example">Click gray line number ‚Üí Red dot appears<br>Auto Run pauses at breakpoints<br>Click again to remove breakpoint<br>Useful for debugging loops and functions</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Auto Run Speed</div>
                        <div class="keyword-description">Adjust execution speed with the slider. Slower speeds help understand complex algorithms step by step.</div>
                        <div class="keyword-example">Slow: Watch each variable change<br>Medium: Good for most algorithms<br>Fast: Quick overview of execution</div>
                    </div>
                </div>

                <div class="keyword-section">
                    <h3>Interface Guide</h3>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Code Editor Panel</div>
                        <div class="keyword-description">Write and edit pseudocode with syntax highlighting. Line numbers show current execution and breakpoints.</div>
                        <div class="keyword-example">Syntax colors: Keywords (blue), Variables (cyan), Numbers (green), Strings (orange)<br>Current line highlighted in yellow<br>Click line numbers for breakpoints</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Variables Panel</div>
                        <div class="keyword-description">Real-time display of all variables and their current values. Updates automatically during execution.</div>
                        <div class="keyword-example">Shows variable names and values<br>Updates immediately after assignment<br>Tracks changes during loops<br>Function parameters displayed during calls</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Output Panel</div>
                        <div class="keyword-description">Displays results from PRINT statements and program output. Shows execution results and error messages.</div>
                        <div class="keyword-example">PRINT statement output<br>Function return values<br>Error messages and warnings<br>Algorithm results and calculations</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Control Buttons</div>
                        <div class="keyword-description">Main execution controls for running and debugging your pseudocode algorithms.</div>
                        <div class="keyword-example">Parse & Start: Begin execution<br>Next Step: Execute one line<br>Step Back: Undo last step<br>Auto Run: Continuous execution<br>Reset: Clear all and restart</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Special exception for function calls that need step-through execution
        class FunctionCallException extends Error {
            constructor(functionName) {
                super(`Function call: ${functionName}`);
                this.name = 'FunctionCallException';
                this.functionName = functionName;
            }
        }

        // Special exception for method calls that need step-through execution
        class MethodCallException extends Error {
            constructor(methodName) {
                super(`Method call: ${methodName}`);
                this.name = 'MethodCallException';
                this.methodName = methodName;
            }
        }

        class MathematicalPseudocodeAnimator {
            constructor() {
                this.currentStep = -1;
                this.isRunning = false;
                this.autoRunning = false;
                this.variables = {};
                this.output = [];
                this.parsedCode = [];
                this.executionContext = { loopStacks: [], ifStack: [], breakpointPaused: false };
                this.autoRunSpeed = 5;
                this.breakpoints = new Set();
                this.executionHistory = [];
                this.stepCounter = 0;
                
                this.examples = {
                    simple: 'BEGIN\n    x ‚Üê 5\n    y ‚Üê 10\n    sum ‚Üê x + y\n    PRINT "Sum: " + sum\nEND',
                    power: 'BEGIN\n    base ‚Üê 3\n    exponent ‚Üê 4\n    result ‚Üê base ^ exponent\n    PRINT base + " to the power of " + exponent + " = " + result\nEND',
                    squares: 'BEGIN\n    FOR i ‚Üê 1 TO 5 DO\n        square ‚Üê i ^ 2\n        PRINT "Square of " + i + " is " + square\n    END FOR\nEND',
                    loop: 'BEGIN\n    count ‚Üê 0\n    total ‚Üê 0\n    WHILE count < 5 DO\n        total ‚Üê total + count\n        count ‚Üê count + 1\n    END WHILE\n    PRINT "Total: " + total\nEND',
                    factorial: 'BEGIN\n    n ‚Üê 5\n    factorial ‚Üê 1\n    i ‚Üê 1\n    WHILE i <= n DO\n        factorial ‚Üê factorial * i\n        i ‚Üê i + 1\n    END WHILE\n    PRINT "Factorial of " + n + " is " + factorial\nEND',
                    logical: 'BEGIN\n    x ‚Üê 7\n    y ‚Üê 3\n    z ‚Üê 0\n    \n    IF x > 5 AND y < 10 THEN\n        PRINT "Both conditions met"\n    END IF\n    \n    IF x < 5 OR y < 5 THEN\n        PRINT "At least one is less than 5"\n    END IF\n    \n    IF (x > 0 AND y > 0) OR z = 0 THEN\n        PRINT "Complex condition is true"\n    END IF\nEND',
                    functions: 'FUNCTION square(x)\n    result ‚Üê x * x\n    RETURN result\nEND FUNCTION\n\nFUNCTION add(a, b)\n    RETURN a + b\nEND FUNCTION\n\nBEGIN\n    num ‚Üê 5\n    sq ‚Üê square(num)\n    doubled ‚Üê add(sq, sq)\n    PRINT "Square of " + num + " is " + sq\n    PRINT "Double the square is " + doubled\nEND',
                    methods: 'METHOD printGreeting(name)\n    PRINT "Hello, " + name + "!"\nEND METHOD\n\nMETHOD showInfo(value, label)\n    PRINT label + ": " + value\nEND METHOD\n\nBEGIN\n    username ‚Üê "Alice"\n    age ‚Üê 25\n    printGreeting(username)\n    showInfo(age, "Age")\n    showInfo(username, "Name")\nEND',
                    steps: 'BEGIN\n    PRINT "Odd numbers from 1 to 10:"\n    FOR i ‚Üê 1 TO 10 STEP 2 DO\n        PRINT i\n    END FOR\n    \n    PRINT "Countdown from 10 to 0:"\n    FOR i ‚Üê 10 TO 0 STEP -1 DO\n        PRINT i\n    END FOR\n    \n    PRINT "Multiples of 3 from 0 to 15:"\n    FOR i ‚Üê 0 TO 15 STEP 3 DO\n        PRINT i\n    END FOR\nEND',
                    factors: 'FUNCTION sqrt(x)\n    result ‚Üê x ^ 0.5\n    RETURN result\nEND FUNCTION\n\nFUNCTION factors(n)\n    facts ‚Üê []\n    limit ‚Üê sqrt(n)\n    factorCount ‚Üê 0\n    FOR i ‚Üê 1 TO limit DO\n        IF n % i = 0 THEN\n            div ‚Üê n / i\n            facts[factorCount] ‚Üê i\n            factorCount ‚Üê factorCount + 1\n            IF i ‚â† div THEN\n                facts[factorCount] ‚Üê div\n                factorCount ‚Üê factorCount + 1\n            END IF\n        END IF\n    END FOR\n    RETURN facts\nEND FUNCTION\n\nBEGIN\n    n ‚Üê 96\n    PRINT "Finding factors of " + n\n    result ‚Üê factors(n)\n    PRINT "Factors: " + result\nEND',
                    bubblesort: 'BEGIN\n    PRINT "Bubble Sort Algorithm"\n    \n    arr ‚Üê [64, 34, 25, 12, 22, 11, 90]\n    n ‚Üê 7\n    sorted ‚Üê 0\n    \n    PRINT "Original array: " + arr\n    \n    FOR i ‚Üê 0 TO n - 2 DO\n        IF sorted = 1 THEN\n            i ‚Üê n\n        END IF\n        \n        IF sorted = 0 THEN\n            swapped ‚Üê 0\n            \n            FOR j ‚Üê 0 TO n - 2 - i DO\n                IF arr[j] > arr[j + 1] THEN\n                    temp ‚Üê arr[j]\n                    newValue ‚Üê arr[j + 1]\n                    arr[j] ‚Üê arr[j + 1]\n                    arr[j + 1] ‚Üê temp\n                    swapped ‚Üê 1\n                    \n                    PRINT "Swapped " + temp + " and " + newValue + ": " + arr\n                END IF\n            END FOR\n            \n            IF swapped = 0 THEN\n                PRINT "Array is already sorted!"\n                sorted ‚Üê 1\n            END IF\n            \n            IF sorted = 0 THEN\n                passNumber ‚Üê i + 1\n                PRINT "After pass " + passNumber + ": " + arr\n            END IF\n        END IF\n    END FOR\n    \n    PRINT "Final sorted array: " + arr\nEND',
                    bisection: 'FUNCTION f(x)\n    result ‚Üê x ^ 2 - x - 1\n    RETURN result\nEND FUNCTION\n\nFUNCTION abs(x)\n    IF x < 0 THEN\n        RETURN -x\n    END IF\n    RETURN x\nEND FUNCTION\n\nBEGIN\n    PRINT "Bisection Method: Find root of x^2 - x - 1"\n    a ‚Üê 1\n    b ‚Üê 2\n    tolerance ‚Üê 0.01\n    iteration ‚Üê 0\n    \n    PRINT "Initial interval: [" + a + ", " + b + "]"\n    \n    WHILE abs(b - a) > tolerance DO\n        iteration ‚Üê iteration + 1\n        c ‚Üê (a + b) / 2\n        fc ‚Üê f(c)\n        fa ‚Üê f(a)\n        \n        PRINT "Iteration " + iteration + ": c = " + c + ", fc = " + fc\n        \n        IF fa * fc < 0 THEN\n            b ‚Üê c\n        ELSE\n            a ‚Üê c\n        END IF\n        \n        PRINT "New interval: [" + a + ", " + b + "]"\n    END WHILE\n    \n    root ‚Üê (a + b) / 2\n    rootValue ‚Üê f(root)\n    PRINT "Root found: " + root\n    PRINT "Verification: rootValue = " + rootValue\nEND',
                    newton: 'FUNCTION f(x)\n    result ‚Üê x ^ 2 - x - 1\n    RETURN result\nEND FUNCTION\n\nFUNCTION fprime(x)\n    result ‚Üê 2 * x - 1\n    RETURN result\nEND FUNCTION\n\nFUNCTION abs(x)\n    IF x < 0 THEN\n        result ‚Üê -x\n    ELSE\n        result ‚Üê x\n    END IF\n    RETURN result\nEND FUNCTION\n\nBEGIN\n    PRINT "Newton\'s Method: Find root of x^2 - x - 1"\n    x0 ‚Üê 1.5\n    tolerance ‚Üê 0.01\n    iteration ‚Üê 0\n    maxIterations ‚Üê 20\n    converged ‚Üê 0\n    \n    PRINT "Starting point: x0 = " + x0\n    \n    WHILE iteration < maxIterations AND converged = 0 DO\n        fx ‚Üê f(x0)\n        fpx ‚Üê fprime(x0)\n        \n        PRINT "Iteration " + iteration + ": x = " + x0 + ", fx = " + fx\n        \n        absFx ‚Üê abs(fx)\n        IF absFx < tolerance THEN\n            PRINT "Root found with desired accuracy!"\n            PRINT "Final result: x = " + x0\n            PRINT "Verification: fx = " + fx\n            converged ‚Üê 1\n        ELSE\n            IF fpx = 0 THEN\n                PRINT "Error: Derivative is zero, cannot continue"\n                converged ‚Üê 1\n            ELSE\n                x1 ‚Üê x0 - fx / fpx\n                diff ‚Üê abs(x1 - x0)\n                \n                IF diff < tolerance THEN\n                    PRINT "Convergence achieved!"\n                    finalValue ‚Üê f(x1)\n                    PRINT "Final result: x = " + x1\n                    PRINT "Verification: finalValue = " + finalValue\n                    converged ‚Üê 1\n                ELSE\n                    x0 ‚Üê x1\n                    iteration ‚Üê iteration + 1\n                END IF\n            END IF\n        END IF\n    END WHILE\n    \n    IF converged = 0 THEN\n        PRINT "Maximum iterations reached"\n        PRINT "Final approximation: x = " + x0\n    END IF\nEND',
                    euler: 'FUNCTION dydx(x, y)\n    result ‚Üê x + y\n    RETURN result\nEND FUNCTION\n\nBEGIN\n    PRINT "Euler\'s Method: Solving dy/dx = x + y"\n    PRINT "Initial conditions: x0 = 0, y0 = 1"\n    PRINT "Step size h = 0.1, solving from x = 0 to x = 1.5"\n    PRINT ""\n    \n    x ‚Üê 0\n    y ‚Üê 1\n    h ‚Üê 0.1\n    xEnd ‚Üê 1.5\n    stepNumber ‚Üê 0\n    \n    PRINT "Step 0: x = " + x + ", y = " + y\n    \n    WHILE x < xEnd DO\n        slope ‚Üê dydx(x, y)\n        yNew ‚Üê y + h * slope\n        xNew ‚Üê x + h\n        stepNumber ‚Üê stepNumber + 1\n        \n        PRINT "Step " + stepNumber + ":"\n        PRINT "  Current point: (" + x + ", " + y + ")"\n        PRINT "  Slope dy/dx = " + x + " + " + y + " = " + slope\n        PRINT "  y_new = " + y + " + " + h + " * " + slope + " = " + yNew\n        PRINT "  New point: (" + xNew + ", " + yNew + ")"\n        PRINT ""\n        \n        x ‚Üê xNew\n        y ‚Üê yNew\n    END WHILE\n    \n    PRINT "Final result: y(" + x + ") ‚âà " + y\n    PRINT ""\n    PRINT "Note: The exact solution to dy/dx = x + y with y(0) = 1"\n    PRINT "is y = 2*e^x - x - 1"\n    exactValue ‚Üê 2 * 2.71828 ^ x - x - 1\n    error ‚Üê y - exactValue\n    PRINT "Exact value: y(" + x + ") = " + exactValue\n    PRINT "Approximation error: " + error\nEND'
                };
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.parseCode();
                    this.start();
                });
                document.getElementById('nextBtn').addEventListener('click', () => this.nextStep());
                document.getElementById('prevBtn').addEventListener('click', () => this.stepBack());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('autoBtn').addEventListener('click', () => this.toggleAutoRun());
                document.getElementById('helpBtn').addEventListener('click', () => this.showHelp());
                
                const codeInput = document.getElementById('codeInput');
                codeInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const start = codeInput.selectionStart;
                        const end = codeInput.selectionEnd;
                        const value = codeInput.value;
                        codeInput.value = value.substring(0, start) + '    ' + value.substring(end);
                        codeInput.selectionStart = codeInput.selectionEnd = start + 4;
                    }
                });

                // Enable Parse & Start button when user types custom code
                codeInput.addEventListener('input', () => {
                    this.updateButtons();
                });

                const modal = document.getElementById('helpModal');
                document.querySelector('.close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
                window.addEventListener('click', (e) => {
                    if (e.target === modal) modal.style.display = 'none';
                });
                
                document.getElementById('exampleSelect').addEventListener('change', (e) => {
                    const example = e.target.value;
                    if (example && this.examples[example]) {
                        document.getElementById('codeInput').value = this.examples[example];
                        this.parseCode();
                        // Reset the dropdown to show placeholder
                        e.target.value = '';
                    }
                });

                const speedSelect = document.getElementById('speedSelect');
                speedSelect.addEventListener('change', (e) => {
                    this.autoRunSpeed = parseInt(e.target.value);
                });
            }

            parseCode() {
                let rawInput = document.getElementById('codeInput').value;
                rawInput = rawInput.replace(/\^/g, '**');
                
                const lines = rawInput.split('\n')
                    .map(line => line.trimEnd()) // Only trim trailing whitespace, preserve indentation
                    .filter(line => line.trim().length > 0) // Filter out completely empty lines
                    .map(line => {
                        line = line.replace(/<-/g, '‚Üê');
                        // Normalize spacing around ‚Üê operator: ensure single space on both sides
                        line = line.replace(/\s*‚Üê\s*/g, ' ‚Üê ');
                        line = line.replace(/\b(if|then|else|elseif|end|while|do|for|to|output|print|input|and|or|begin|function|method|return|call)\b/gi,
                            match => match.toUpperCase());
                        return line;
                    });

                const validation = this.validateCode(lines);
                const messageDiv = document.getElementById('validationMessage');
                
                if (validation.errors.length > 0) {
                    messageDiv.className = 'validation-message error';
                    messageDiv.style.display = 'block';
                    messageDiv.innerHTML = '<strong>Errors:</strong><br>' + validation.errors.join('<br>');
                    this.parsedCode = [];
                    this.renderParsedCode();
                    this.updateButtons();
                    return;
                }
                
                messageDiv.className = 'validation-message success';
                messageDiv.style.display = 'block';
                messageDiv.innerHTML = '<strong>‚úî Code parsed successfully!</strong>';
                
                this.parsedCode = lines;
                this.breakpoints.clear();
                this.executionHistory = [];
                this.stepCounter = 0;
                this.renderParsedCode();
                this.initializeVariables();
                this.updateButtons();
                this.updateDebugInfo();
                
                setTimeout(() => messageDiv.style.display = 'none', 3000);
            }

            validateCode(lines) {
                const errors = [];
                const blockStack = [];
                let hasBegin = false;
                let hasEnd = false;
                let inMainCode = false;
                let functionCount = 0;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmedLine = line.trim(); // Use trimmed version for validation
                    const lineNum = i + 1;

                    // Check for main code structure
                    if (trimmedLine === 'BEGIN') {
                        if (hasBegin) {
                            errors.push(`Line ${lineNum}: Multiple BEGIN statements not allowed`);
                        }
                        hasBegin = true;
                        inMainCode = true;
                        blockStack.push('BEGIN');
                    } else if (trimmedLine === 'END') {
                        if (!hasBegin) {
                            errors.push(`Line ${lineNum}: END without BEGIN`);
                        } else if (blockStack[blockStack.length - 1] !== 'BEGIN') {
                            errors.push(`Line ${lineNum}: END must close BEGIN, not ${blockStack[blockStack.length - 1]}`);
                        } else {
                            hasEnd = true;
                            inMainCode = false;
                            blockStack.pop();
                        }
                    }
                    // Check for function/method definitions
                    else if (trimmedLine.startsWith('FUNCTION ') || trimmedLine.startsWith('METHOD ')) {
                        if (inMainCode) {
                            errors.push(`Line ${lineNum}: Functions/methods must be defined outside the main BEGIN/END block`);
                        }
                        const match = trimmedLine.match(/^(FUNCTION|METHOD)\s+(\w+)\s*(\([^)]*\))?\s*$/);
                        if (!match) {
                            errors.push(`Line ${lineNum}: Invalid function/method syntax. Use 'FUNCTION name' or 'FUNCTION name(params)'`);
                        }
                        blockStack.push(trimmedLine.startsWith('FUNCTION') ? 'FUNCTION' : 'METHOD');
                        functionCount++;
                    }
                    // Check for existing block structures
                    else if (trimmedLine.includes('‚Üê') && !trimmedLine.startsWith('IF ') && !trimmedLine.startsWith('ELSE IF ') &&
                        !trimmedLine.startsWith('WHILE ') && !trimmedLine.startsWith('FOR ') &&
                        !trimmedLine.startsWith('OUTPUT ') && !trimmedLine.startsWith('PRINT ') &&
                        !trimmedLine.startsWith('FUNCTION ') && !trimmedLine.startsWith('METHOD ')) {
                        const parts = trimmedLine.split('‚Üê');
                        if (parts.length !== 2 || parts[0].trim() === '' || parts[1].trim() === '') {
                            errors.push(`Line ${lineNum}: Invalid assignment format`);
                        }
                    } else if (trimmedLine.startsWith('IF ')) {
                        if (!trimmedLine.includes('THEN')) errors.push(`Line ${lineNum}: IF must end with THEN`);
                        blockStack.push('IF');
                    } else if (trimmedLine.startsWith('WHILE ')) {
                        if (!trimmedLine.includes('DO')) errors.push(`Line ${lineNum}: WHILE must end with DO`);
                        blockStack.push('WHILE');
                    } else if (trimmedLine.startsWith('FOR ')) {
                        if (!trimmedLine.includes('‚Üê') || !trimmedLine.includes('TO') || !trimmedLine.includes('DO')) {
                            errors.push(`Line ${lineNum}: FOR must be 'FOR var ‚Üê start TO end [STEP increment] DO'`);
                        }
                        blockStack.push('FOR');
                    } else if (trimmedLine.match(/^END (IF|WHILE|FOR|FUNCTION|METHOD)$/)) {
                        const endType = trimmedLine.split(' ')[1];
                        if (blockStack.length === 0) {
                            errors.push(`Line ${lineNum}: Unexpected END statement`);
                        } else {
                            const expectedEnd = blockStack[blockStack.length - 1];
                            if (expectedEnd !== endType) {
                                errors.push(`Line ${lineNum}: Expected END ${expectedEnd}, found END ${endType}`);
                            } else {
                                blockStack.pop();
                            }
                        }
                    }
                }

                // Check for required BEGIN/END structure
                if (!hasBegin) {
                    errors.push("Main code must be enclosed in BEGIN...END block");
                }
                if (hasBegin && !hasEnd) {
                    errors.push("BEGIN block must be closed with END");
                }

                if (blockStack.length > 0) {
                    errors.push(`Missing END statements for: ${blockStack.join(', ')}`);
                }

                return { errors };
            }

            applySyntaxHighlighting(line, lineElement) {
                lineElement.innerHTML = '';
                const tokens = this.tokenizeLine(line);
                
                tokens.forEach(token => {
                    const span = document.createElement('span');
                    span.textContent = token.text;
                    span.className = token.type;
                    lineElement.appendChild(span);
                });
            }

            tokenizeLine(line) {
                const tokens = [];
                let i = 0;
                
                while (i < line.length) {
                    if (line[i] === ' ') {
                        let spaces = '';
                        while (i < line.length && line[i] === ' ') {
                            spaces += line[i];
                            i++;
                        }
                        tokens.push({ text: spaces, type: '' });
                        continue;
                    }
                    
                    if (line[i] === '"') {
                        let str = '"';
                        i++;
                        while (i < line.length && line[i] !== '"') {
                            str += line[i];
                            i++;
                        }
                        if (i < line.length) str += line[i++];
                        tokens.push({ text: str, type: 'string' });
                        continue;
                    }
                    
                    if (/\d/.test(line[i])) {
                        let num = '';
                        while (i < line.length && /[\d.]/.test(line[i])) {
                            num += line[i];
                            i++;
                        }
                        tokens.push({ text: num, type: 'number' });
                        continue;
                    }
                    
                    if (line[i] === '‚Üê') {
                        tokens.push({ text: '‚Üê', type: 'assignment' });
                        i++;
                        continue;
                    }
                    
                    if (line.substr(i, 2) === '**') {
                        tokens.push({ text: '**', type: 'operator' });
                        i += 2;
                        continue;
                    }
                    
                    if (/[+\-*/><=()]/.test(line[i])) {
                        if (i + 1 < line.length && line.substr(i, 2).match(/>=|<=/)) {
                            tokens.push({ text: line.substr(i, 2), type: 'operator' });
                            i += 2;
                        } else {
                            tokens.push({ text: line[i], type: 'operator' });
                            i++;
                        }
                        continue;
                    }
                    
                    if (/[a-zA-Z_]/.test(line[i])) {
                        let word = '';
                        while (i < line.length && /[a-zA-Z0-9_]/.test(line[i])) {
                            word += line[i];
                            i++;
                        }
                        
                        const keywords = ['IF', 'THEN', 'ELSE', 'ELSEIF', 'END', 'WHILE', 'DO', 'FOR', 'TO', 'STEP', 'OUTPUT', 'PRINT', 'INPUT', 'AND', 'OR', 'BEGIN', 'FUNCTION', 'METHOD', 'RETURN', 'CALL'];
                        const type = keywords.includes(word) ? 'keyword' : 'variable';
                        tokens.push({ text: word, type });
                        continue;
                    }
                    
                    tokens.push({ text: line[i], type: '' });
                    i++;
                }
                
                return tokens;
            }

            renderParsedCode() {
                const pseudocodeDiv = document.getElementById('pseudocode');
                if (this.parsedCode.length === 0) {
                    pseudocodeDiv.innerHTML = '<div style="color: #999; font-style: italic; padding: 20px;">No valid code to display</div>';
                    return;
                }

                pseudocodeDiv.innerHTML = '';

                this.parsedCode.forEach((line, index) => {
                    
                    const isBreakpoint = this.breakpoints.has(index);
                    
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'pseudocode-line';
                    lineDiv.dataset.line = index;
                    
                    const lineNumDiv = document.createElement('div');
                    lineNumDiv.className = `line-number ${isBreakpoint ? 'breakpoint' : ''}`;
                    lineNumDiv.dataset.line = index;
                    lineNumDiv.textContent = index + 1;
                    lineNumDiv.addEventListener('click', (e) => {
                        const lineIndex = parseInt(e.target.dataset.line);
                        this.toggleBreakpoint(lineIndex);
                    });
                    
                    const lineContentDiv = document.createElement('div');
                    lineContentDiv.className = 'line-content';

                    this.applySyntaxHighlighting(line, lineContentDiv); // Use original line with preserved indentation
                    
                    lineDiv.appendChild(lineNumDiv);
                    lineDiv.appendChild(lineContentDiv);
                    pseudocodeDiv.appendChild(lineDiv);
                });
            }

            toggleBreakpoint(lineIndex) {
                if (this.breakpoints.has(lineIndex)) {
                    this.breakpoints.delete(lineIndex);
                } else {
                    this.breakpoints.add(lineIndex);
                }
                this.renderParsedCode();
                this.updateDebugInfo();
            }

            saveExecutionState() {
                this.executionHistory.push({
                    step: this.currentStep,
                    variables: JSON.parse(JSON.stringify(this.variables)),
                    output: [...this.output],
                    executionContext: JSON.parse(JSON.stringify(this.executionContext)),
                    stepCounter: this.stepCounter
                });
            }

            stepBack() {
                if (this.executionHistory.length === 0) return;
                
                const previousState = this.executionHistory.pop();
                this.currentStep = previousState.step;
                this.variables = previousState.variables;
                this.output = previousState.output;
                this.executionContext = previousState.executionContext;
                this.stepCounter = previousState.stepCounter;
                
                this.renderVariables();
                this.renderOutput();
                this.highlightLine(this.currentStep);
                this.updateButtons();
                this.updateDebugInfo();
            }

            initializeVariables() {
                this.variables = {};
                this.renderVariables();
                this.clearOutput();
            }

            renderVariables() {
                const variablesDiv = document.getElementById('variables');

                // Filter out temporary variables that start with _temp
                const displayVariables = Object.entries(this.variables).filter(([name, value]) =>
                    !name.startsWith('_temp')
                );

                if (displayVariables.length === 0) {
                    variablesDiv.innerHTML = '<div style="color: #999; font-style: italic;">No variables defined yet</div>';
                    return;
                }

                variablesDiv.innerHTML = displayVariables.map(([name, value]) =>
                    `<div class="variable-item" data-var="${name}">
                        <span class="variable-name">${name}:</span>
                        <span class="variable-value">${this.formatValue(value)}</span>
                    </div>`
                ).join('');
            }

            formatValue(value) {
                if (Array.isArray(value)) return `[${value.join(', ')}]`;
                if (typeof value === 'string') return `"${value}"`;
                return String(value);
            }

            updateVariable(name, value, highlight = true) {
                // Check if this is an array assignment (e.g., "arr[index]")
                const arrayMatch = name.match(/^(\w+)\[(.+)\]$/);
                if (arrayMatch) {
                    const arrayName = arrayMatch[1];
                    const indexExpr = arrayMatch[2];
                    const index = this.evaluateExpression(indexExpr);

                    // Initialize array if it doesn't exist
                    if (!this.variables[arrayName]) {
                        this.variables[arrayName] = [];
                    }

                    // Ensure the array is large enough
                    if (!Array.isArray(this.variables[arrayName])) {
                        this.variables[arrayName] = [];
                    }

                    // Set the array element
                    this.variables[arrayName][index] = value;

                    // Use the array name for highlighting
                    name = arrayName;
                } else {
                    // Regular variable assignment
                    this.variables[name] = value;
                }

                this.renderVariables();
                if (highlight) {
                    const varItem = document.querySelector(`[data-var="${name}"]`);
                    if (varItem) {
                        varItem.classList.add('updated');
                        setTimeout(() => varItem.classList.remove('updated'), 1000);
                    }
                }
            }

            evaluateExpression(expr) {
                expr = expr.trim();

                // Check for function calls first
                const funcCallMatch = expr.match(/^(\w+)\s*\(([^)]*)\)$/);
                if (funcCallMatch) {
                    const funcName = funcCallMatch[1];
                    const argsStr = funcCallMatch[2];
                    return this.callFunction(funcName, argsStr);
                }

                // Check for function calls in complex expressions (like x + func(y))
                if (expr.includes('(') && expr.includes(')')) {
                    // Replace function calls with their return values
                    expr = expr.replace(/(\w+)\s*\(([^)]*)\)/g, (match, funcName, argsStr) => {
                        if (this.executionContext.functions && this.executionContext.functions[funcName]) {
                            return this.callFunction(funcName, argsStr);
                        }
                        return match; // Not a function call, leave as is
                    });
                }

                // Check if this should be treated as string concatenation
                if (this.shouldUseStringEvaluation(expr)) {
                    return this.evaluateStringExpression(expr);
                }

                if (expr.includes('[') && expr.includes(']')) {
                    const match = expr.match(/(\w+)\[(.+)\]/);
                    if (match) {
                        const arrayName = match[1];
                        const indexExpr = match[2];
                        const index = this.evaluateExpression(indexExpr);
                        return this.variables[arrayName] ? this.variables[arrayName][index] : undefined;
                    }
                }
                
                if (/^\w+$/.test(expr) && this.variables.hasOwnProperty(expr)) {
                    return this.variables[expr];
                }
                
                if (/^-?\d+(\.\d+)?$/.test(expr)) {
                    return parseFloat(expr);
                }
                
                if ((expr.startsWith('"') && expr.endsWith('"')) || 
                    (expr.startsWith("'") && expr.endsWith("'"))) {
                    return expr.slice(1, -1);
                }
                
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const content = expr.slice(1, -1).trim();
                    if (content === '') return [];
                    return content.split(',').map(item => this.evaluateExpression(item.trim()));
                }
                
                return this.evaluateArithmetic(expr);
            }

            shouldUseStringEvaluation(expr) {
                // If expression contains quotes, it's definitely string concatenation
                if (expr.includes('"') || expr.includes("'")) {
                    return true;
                }

                // If expression contains + but no other arithmetic operators, check if any variables are strings
                if (expr.includes('+') && !expr.match(/[*\-/^()]/)) {
                    // Extract variable names from the expression
                    const varNames = expr.match(/\b[a-zA-Z_]\w*\b/g) || [];
                    for (const varName of varNames) {
                        if (this.variables.hasOwnProperty(varName) && typeof this.variables[varName] === 'string') {
                            return true;
                        }
                    }
                }

                return false;
            }

            callFunction(funcName, argsStr) {
                // Check if function exists
                if (!this.executionContext.functions || !this.executionContext.functions[funcName]) {
                    throw new Error(`Function '${funcName}' is not defined`);
                }

                const func = this.executionContext.functions[funcName];

                // Parse arguments
                const args = argsStr.trim() ? argsStr.split(',').map(arg => this.evaluateExpression(arg.trim())) : [];

                // Check parameter count
                if (args.length !== func.params.length) {
                    throw new Error(`Function '${funcName}' expects ${func.params.length} arguments, got ${args.length}`);
                }

                // Check if we're returning from this function call
                if (this.executionContext.pendingReturn &&
                    this.executionContext.pendingReturn.functionName === funcName) {
                    const returnValue = this.executionContext.pendingReturn.returnValue;
                    this.executionContext.pendingReturn = null;
                    console.log(`Function ${funcName} returning value:`, returnValue); // Debug
                    return returnValue;
                }

                // Initiate the function call for step-by-step execution
                this.initiateFunctionCall(funcName, args, func);

                // Throw a special exception to pause execution and jump to function
                throw new FunctionCallException(funcName);
            }

            callMethod(methodName, fullLine) {
                // Check if method exists
                if (!this.executionContext.functions || !this.executionContext.functions[methodName]) {
                    throw new Error(`Method '${methodName}' is not defined`);
                }

                const method = this.executionContext.functions[methodName];

                // Ensure it's actually a method
                if (method.type !== 'METHOD') {
                    throw new Error(`'${methodName}' is not a method`);
                }

                // Parse arguments from the full line
                const argsMatch = fullLine.match(/\(([^)]*)\)/);
                const argsStr = argsMatch ? argsMatch[1] : '';
                const args = argsStr.trim() ? argsStr.split(',').map(arg => this.evaluateExpression(arg.trim())) : [];

                // Check parameter count
                if (args.length !== method.params.length) {
                    throw new Error(`Method '${methodName}' expects ${method.params.length} arguments, got ${args.length}`);
                }

                // Check if we're returning from this method call
                if (this.executionContext.pendingReturn &&
                    this.executionContext.pendingReturn.functionName === methodName) {
                    // Method execution completed, clear pending return and continue
                    this.executionContext.pendingReturn = null;
                    console.log(`Method ${methodName} completed`); // Debug
                    return;
                }

                // Initiate the method call for step-by-step execution
                this.initiateMethodCall(methodName, args, method);

                // Throw a special exception to pause execution and jump to method
                throw new MethodCallException(methodName);
            }

            initiateFunctionCall(funcName, args, func) {
                // Save current execution state to call stack
                const callFrame = {
                    functionName: funcName,
                    returnLine: this.currentStep,
                    returnVariables: JSON.parse(JSON.stringify(this.variables)),
                    waitingForExecution: this.executionContext.waitingForExecution,
                    returnValue: undefined
                };

                this.executionContext.callStack.push(callFrame);

                // Set up function parameters as local variables (clear all globals)
                this.variables = {};
                for (let i = 0; i < func.params.length; i++) {
                    this.variables[func.params[i]] = args[i];
                }

                // Jump to function start (skip the FUNCTION declaration line)
                this.currentStep = func.startLine;
                this.executionContext.waitingForExecution = true;
                this.executionContext.inFunction = true;

                // Render variables to show the new local scope
                this.renderVariables();
            }

            initiateMethodCall(methodName, args, method) {
                // Save current execution state to call stack
                const callFrame = {
                    functionName: methodName, // Use same property name for consistency
                    returnLine: this.currentStep,
                    returnVariables: JSON.parse(JSON.stringify(this.variables)),
                    waitingForExecution: this.executionContext.waitingForExecution,
                    returnValue: undefined,
                    isMethod: true // Flag to distinguish from function calls
                };

                this.executionContext.callStack.push(callFrame);

                // Set up method parameters as local variables (clear all globals)
                this.variables = {};
                for (let i = 0; i < method.params.length; i++) {
                    this.variables[method.params[i]] = args[i];
                }

                // Jump to method start (skip the METHOD declaration line)
                this.currentStep = method.startLine;
                this.executionContext.waitingForExecution = true;
                this.executionContext.inFunction = true; // Reuse the same flag

                // Render variables to show the new local scope
                this.renderVariables();
            }

            returnFromFunction(returnValue) {
                console.log('Returning from function with value:', returnValue); // Debug

                // Pop the call frame from the stack
                const callFrame = this.executionContext.callStack.pop();

                if (callFrame) {
                    console.log('Restoring to line:', callFrame.returnLine); // Debug
                    console.log('Function name:', callFrame.functionName); // Debug

                    // Restore the previous execution state
                    this.currentStep = callFrame.returnLine;
                    this.variables = callFrame.returnVariables;
                    this.executionContext.inFunction = this.executionContext.callStack.length > 0;

                    // Set up the return value to be used when the line is re-executed
                    this.executionContext.pendingReturn = {
                        functionName: callFrame.functionName,
                        returnValue: returnValue
                    };

                    console.log('Set pendingReturn:', this.executionContext.pendingReturn); // Debug

                    // Update the UI to reflect the restored state
                    this.renderVariables();

                    // Set up for re-execution of the calling line
                    this.executionContext.waitingForExecution = true;

                    // Highlight the calling line again
                    this.highlightLine(this.currentStep);
                    this.updateButtons();
                    this.updateDebugInfo();
                }
            }

            evaluateStringExpression(expr) {
                const parts = [];
                let current = '';
                let inQuotes = false;
                let quoteChar = '';

                // Parse the expression respecting quotes
                for (let i = 0; i < expr.length; i++) {
                    const char = expr[i];
                    if ((char === '"' || char === "'") && !inQuotes) {
                        inQuotes = true;
                        quoteChar = char;
                        current += char;
                    } else if (char === quoteChar && inQuotes) {
                        inQuotes = false;
                        current += char;
                    } else if (char === '+' && !inQuotes) {
                        parts.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                if (current.trim()) {
                    parts.push(current.trim());
                }

                let result = '';
                for (const part of parts) {
                    // Don't evaluate as expression if it's a string literal
                    if ((part.startsWith('"') && part.endsWith('"')) ||
                        (part.startsWith("'") && part.endsWith("'"))) {
                        result += part.slice(1, -1);
                    } else {
                        // For non-string parts, use simple evaluation to avoid function call issues
                        const value = this.evaluateSimpleExpression(part);
                        result += String(value);
                    }
                }
                return result;
            }

            evaluateSimpleExpression(expr) {
                expr = expr.trim();

                // Check if it's a variable
                if (/^\w+$/.test(expr) && this.variables.hasOwnProperty(expr)) {
                    return this.variables[expr];
                }

                // Check if it's a number
                if (/^-?\d+(\.\d+)?$/.test(expr)) {
                    return parseFloat(expr);
                }

                // Check if it's a string literal
                if ((expr.startsWith('"') && expr.endsWith('"')) ||
                    (expr.startsWith("'") && expr.endsWith("'"))) {
                    return expr.slice(1, -1);
                }

                // For anything else, return as is
                return expr;
            }

            evaluateArithmetic(expr) {
                let processedExpr = expr;
                
                const sortedVars = Object.keys(this.variables).sort((a, b) => b.length - a.length);
                for (const name of sortedVars) {
                    const value = this.variables[name];
                    if (typeof value === 'number') {
                        processedExpr = processedExpr.replace(new RegExp(`\\b${name}\\b`, 'g'), `(${value})`);
                    }
                }
                
                try {
                    return Function(`"use strict"; return (${processedExpr})`)();
                } catch (e) {
                    console.log('Arithmetic error:', e, 'Expression:', processedExpr);
                    return 0;
                }
            }

            evaluateCondition(condition) {
                condition = condition.trim();
                condition = condition.replace(/‚â•/g, '>=').replace(/‚â§/g, '<=').replace(/‚â†/g, '!=');
                
                // Handle parentheses recursively
                while (condition.includes('(')) {
                    condition = condition.replace(/\([^()]+\)/g, (match) => {
                        const inner = match.slice(1, -1);
                        return this.evaluateCondition(inner) ? 'TRUE' : 'FALSE';
                    });
                }
                
                // Handle OR operator (lower precedence)
                if (condition.includes(' OR ')) {
                    const parts = condition.split(' OR ');
                    for (const part of parts) {
                        if (this.evaluateCondition(part.trim())) {
                            return true;
                        }
                    }
                    return false;
                }
                
                // Handle AND operator (higher precedence)
                if (condition.includes(' AND ')) {
                    const parts = condition.split(' AND ');
                    for (const part of parts) {
                        if (!this.evaluateCondition(part.trim())) {
                            return false;
                        }
                    }
                    return true;
                }
                
                // Handle boolean literals from parentheses evaluation
                if (condition === 'TRUE') return true;
                if (condition === 'FALSE') return false;
                
                // Handle simple comparisons with proper parentheses handling
                const operators = ['>=', '<=', '!=', '>', '<', '='];
                for (const op of operators) {
                    const opIndex = this.findOperatorIndex(condition, op);
                    if (opIndex !== -1) {
                        const leftPart = condition.substring(0, opIndex).trim();
                        const rightPart = condition.substring(opIndex + op.length).trim();

                        const leftVal = this.evaluateExpression(leftPart);
                        const rightVal = this.evaluateExpression(rightPart);

                        switch (op) {
                            case '>=': return leftVal >= rightVal;
                            case '<=': return leftVal <= rightVal;
                            case '!=': return leftVal != rightVal;
                            case '>': return leftVal > rightVal;
                            case '<': return leftVal < rightVal;
                            case '=': return leftVal == rightVal;
                        }
                    }
                }
                return false;
            }

            findOperatorIndex(condition, operator) {
                let parenCount = 0;
                let i = 0;

                while (i <= condition.length - operator.length) {
                    const char = condition[i];

                    if (char === '(') {
                        parenCount++;
                    } else if (char === ')') {
                        parenCount--;
                    } else if (parenCount === 0) {
                        // Only check for operators when we're not inside parentheses
                        if (condition.substring(i, i + operator.length) === operator) {
                            // Make sure this isn't part of a longer operator
                            const prevChar = i > 0 ? condition[i - 1] : ' ';
                            const nextChar = i + operator.length < condition.length ? condition[i + operator.length] : ' ';

                            // For >= and <= we need to make sure we don't match > or < that are part of them
                            if (operator === '>' && nextChar === '=') {
                                i++;
                                continue;
                            }
                            if (operator === '<' && nextChar === '=') {
                                i++;
                                continue;
                            }

                            return i;
                        }
                    }
                    i++;
                }
                return -1;
            }

            evaluateFunctionCallSync(functionCall) {
                // Parse the function call
                const match = functionCall.match(/^(\w+)\s*\(([^)]*)\)$/);
                if (!match) return null;

                const funcName = match[1];
                const argsStr = match[2];

                // Check if function exists
                if (!this.executionContext.functions || !this.executionContext.functions[funcName]) {
                    return null;
                }

                const func = this.executionContext.functions[funcName];

                // Parse arguments
                const args = argsStr.trim() ? argsStr.split(',').map(arg => this.evaluateExpression(arg.trim())) : [];

                // Check parameter count
                if (args.length !== func.params.length) {
                    throw new Error(`Function '${funcName}' expects ${func.params.length} arguments, got ${args.length}`);
                }

                // Save current state
                const savedVariables = JSON.parse(JSON.stringify(this.variables));
                const savedInFunction = this.executionContext.inFunction;

                try {
                    // Set up function parameters as local variables
                    this.variables = {};
                    for (let i = 0; i < func.params.length; i++) {
                        this.variables[func.params[i]] = args[i];
                    }
                    this.executionContext.inFunction = true;

                    // Execute function body synchronously
                    let i = func.startLine + 1;
                    while (i < func.endLine) {
                        const line = this.parsedCode[i].trim();
                        console.log(`Sync executing: ${line}`); // Debug

                        if (line.startsWith('RETURN ')) {
                            const returnExpr = line.substring(7).trim();
                            const returnValue = this.evaluateExpression(returnExpr);
                            console.log(`Sync return: ${returnValue}`); // Debug
                            return returnValue;
                        } else if (line === 'RETURN') {
                            console.log(`Sync return: undefined`); // Debug
                            return undefined;
                        } else if (line.startsWith('IF ')) {
                            const thenIndex = line.indexOf('THEN');
                            if (thenIndex > 0) {
                                const condition = line.substring(3, thenIndex).trim();
                                const conditionResult = this.evaluateCondition(condition);
                                console.log(`Sync IF condition "${condition}" = ${conditionResult}`); // Debug

                                if (!conditionResult) {
                                    // Skip to END IF or ELSE
                                    let depth = 1;
                                    i++;
                                    while (i < func.endLine && depth > 0) {
                                        const nextLine = this.parsedCode[i].trim();
                                        if (nextLine.startsWith('IF ')) depth++;
                                        else if (nextLine === 'END IF') depth--;
                                        else if (nextLine === 'ELSE' && depth === 1) break;
                                        i++;
                                    }
                                    continue;
                                }
                            }
                        } else if (line === 'ELSE') {
                            // Skip to END IF
                            let depth = 1;
                            i++;
                            while (i < func.endLine && depth > 0) {
                                const nextLine = this.parsedCode[i].trim();
                                if (nextLine.startsWith('IF ')) depth++;
                                else if (nextLine === 'END IF') depth--;
                                i++;
                            }
                            continue;
                        } else if (line === 'END IF') {
                            // Continue normal execution
                        } else if (line.includes('‚Üê')) {
                            // Handle assignments within the function
                            const parts = line.split('‚Üê');
                            if (parts.length === 2) {
                                const varName = parts[0].trim();
                                const value = this.evaluateExpression(parts[1].trim());
                                this.updateVariable(varName, value);
                                console.log(`Sync assignment: ${varName} = ${value}`); // Debug
                            }
                        }
                        i++;
                    }
                    return undefined;
                } finally {
                    // Restore state
                    this.variables = savedVariables;
                    this.executionContext.inFunction = savedInFunction;
                }
            }

            preprocessConditionWithFunctionCalls(condition) {
                // Find function calls in the condition and replace them with temporary variables
                let processedCondition = condition;
                const tempVarCounter = this.tempVarCounter || 0;

                // Find function calls: word followed by parentheses
                const functionCallRegex = /(\w+)\s*\([^)]*\)/g;
                let match;
                let replacements = [];

                while ((match = functionCallRegex.exec(condition)) !== null) {
                    const functionCall = match[0];
                    const functionName = match[1];

                    // Check if this is actually a function we know about
                    if (this.executionContext.functions && this.executionContext.functions[functionName]) {
                        const tempVarName = `_temp${tempVarCounter + replacements.length}`;
                        replacements.push({
                            original: functionCall,
                            tempVar: tempVarName,
                            expression: functionCall
                        });
                    }
                }

                // Apply replacements and evaluate function calls
                for (const replacement of replacements) {
                    try {
                        const value = this.evaluateFunctionCallSync(replacement.expression);
                        if (value !== null) {
                            this.updateVariable(replacement.tempVar, value);
                            processedCondition = processedCondition.replace(replacement.original, replacement.tempVar);
                            console.log(`Created temp variable: ${replacement.tempVar} = ${value} (from ${replacement.original})`); // Debug
                        }
                    } catch (error) {
                        console.log(`Error evaluating function call ${replacement.original}:`, error);
                    }
                }

                this.tempVarCounter = tempVarCounter + replacements.length;
                return processedCondition;
            }

            highlightLine(lineIndex) {
                document.querySelectorAll('.pseudocode-line').forEach((line, index) => {
                    line.classList.remove('current', 'completed', 'error');
                    if (index < lineIndex) {
                        line.classList.add('completed');
                    } else if (index === lineIndex) {
                        line.classList.add('current');
                        // Auto-scroll to keep the current line visible
                        this.scrollToLine(line);
                    }
                });
            }

            scrollToLine(lineElement) {
                const codeContainer = document.getElementById('pseudocode');
                if (!codeContainer || !lineElement) return;

                const containerRect = codeContainer.getBoundingClientRect();
                const lineRect = lineElement.getBoundingClientRect();
                const containerScrollTop = codeContainer.scrollTop;
                const lineOffsetTop = lineElement.offsetTop;
                const containerHeight = codeContainer.clientHeight;
                const lineHeight = lineElement.offsetHeight;

                // Check if line is above the visible area
                if (lineRect.top < containerRect.top) {
                    // Scroll up to show the line with some padding (20px)
                    codeContainer.scrollTo({
                        top: lineOffsetTop - 20,
                        behavior: 'smooth'
                    });
                }
                // Check if line is below the visible area
                else if (lineRect.bottom > containerRect.bottom) {
                    // Scroll down to show the line with some padding (20px)
                    codeContainer.scrollTo({
                        top: lineOffsetTop - containerHeight + lineHeight + 20,
                        behavior: 'smooth'
                    });
                }
                // If line is partially visible or needs centering for better visibility
                else if (lineRect.top < containerRect.top + 50 || lineRect.bottom > containerRect.bottom - 50) {
                    // Center the line in the view for better visibility
                    codeContainer.scrollTo({
                        top: lineOffsetTop - (containerHeight / 2) + (lineHeight / 2),
                        behavior: 'smooth'
                    });
                }
            }

            addOutput(text) {
                this.output.push(text);
                this.renderOutput();
            }

            renderOutput() {
                document.getElementById('output').innerHTML = this.output.join('<br>');
            }

            clearOutput() {
                this.output = [];
                this.renderOutput();
            }

            start() {
                if (this.parsedCode.length === 0) {
                    alert('Please parse your code first!');
                    return;
                }

                // Find the BEGIN statement to start main program execution
                let beginIndex = -1;
                for (let i = 0; i < this.parsedCode.length; i++) {
                    if (this.parsedCode[i].trim() === 'BEGIN') {
                        beginIndex = i;
                        break;
                    }
                }

                if (beginIndex === -1) {
                    alert('No BEGIN statement found! Main code must be enclosed in BEGIN...END.');
                    return;
                }

                this.isRunning = true;
                this.currentStep = beginIndex - 1; // Start just before BEGIN so nextStep() lands on BEGIN
                this.stepCounter = 0;
                this.executionContext = {
                    loopStacks: [],
                    ifStack: [],
                    breakpointPaused: false,
                    waitingForExecution: false,
                    functions: this.parseFunctions(),
                    callStack: [],
                    inFunction: false,
                    pendingReturn: null
                };
                this.tempVarCounter = 0;
                this.executionHistory = [];
                this.initializeVariables();
                this.updateButtons();
                this.updateDebugInfo();
                this.nextStep();
            }

            parseFunctions() {
                const functions = {};
                let i = 0;

                while (i < this.parsedCode.length) {
                    const line = this.parsedCode[i];
                    const trimmedLine = line.trim();

                    if (trimmedLine.startsWith('FUNCTION ') || trimmedLine.startsWith('METHOD ')) {
                        const match = trimmedLine.match(/^(FUNCTION|METHOD)\s+(\w+)\s*(\([^)]*\))?\s*$/);
                        if (match) {
                            const type = match[1];
                            const name = match[2];
                            const params = match[3] ? match[3].slice(1, -1).split(',').map(p => p.trim()).filter(p => p) : [];

                            const startLine = i;
                            let endLine = -1;
                            let depth = 1;

                            // Find the corresponding END FUNCTION/METHOD
                            for (let j = i + 1; j < this.parsedCode.length; j++) {
                                const nextLine = this.parsedCode[j].trim();
                                if (nextLine.startsWith('FUNCTION ') || nextLine.startsWith('METHOD ')) {
                                    depth++;
                                } else if (nextLine === `END ${type}`) {
                                    depth--;
                                    if (depth === 0) {
                                        endLine = j;
                                        break;
                                    }
                                }
                            }

                            if (endLine !== -1) {
                                functions[name] = {
                                    type: type,
                                    params: params,
                                    startLine: startLine,
                                    endLine: endLine,
                                    body: this.parsedCode.slice(startLine + 1, endLine)
                                };
                            }

                            i = endLine + 1;
                        } else {
                            i++;
                        }
                    } else {
                        i++;
                    }
                }

                return functions;
            }

            reset() {
                this.isRunning = false;
                this.autoRunning = false;
                this.currentStep = -1;
                this.stepCounter = 0;
                this.executionContext = { loopStacks: [], ifStack: [], breakpointPaused: false, waitingForExecution: false, callStack: [], inFunction: false, pendingReturn: null };
                this.executionHistory = [];
                this.initializeVariables();
                this.updateButtons();
                this.updateDebugInfo();
                document.querySelectorAll('.pseudocode-line').forEach(line => {
                    line.classList.remove('current', 'completed', 'error');
                });
            }

            toggleAutoRun() {
                if (this.autoRunning) {
                    this.autoRunning = false;
                    this.updateButtons();
                } else {
                    if (!this.isRunning) {
                        this.start();
                    }
                    this.autoRunning = true;
                    this.updateButtons();
                    this.autoExecute();
                }
            }

            autoExecute() {
                if (this.autoRunning && this.isRunning) {
                    this.nextStep();
                    if (this.isRunning) {
                        const delay = Math.max(50, 3100 - (this.autoRunSpeed * 300));
                        setTimeout(() => this.autoExecute(), delay);
                    }
                }
            }

            nextStep() {
                if (!this.isRunning) return;

                // If this is the first step or we just executed a line, move to next line
                // BUT if we have a pending return, we need to stay on the current line to re-execute
                if (!this.executionContext.waitingForExecution && !this.executionContext.pendingReturn) {
                    this.currentStep++;

                    if (this.currentStep >= this.parsedCode.length) {
                        this.isRunning = false;
                        this.autoRunning = false;
                        this.updateButtons();
                        this.updateDebugInfo();
                        return;
                    }

                    // Highlight the line and wait for execution
                    this.highlightLine(this.currentStep);
                    this.executionContext.waitingForExecution = true;

                    // Check for breakpoint - pause auto-run if we hit one
                    if (this.breakpoints.has(this.currentStep)) {
                        if (this.autoRunning) {
                            this.autoRunning = false;
                        }
                        this.executionContext.breakpointPaused = true;
                    } else {
                        this.executionContext.breakpointPaused = false;
                    }

                    this.updateButtons();
                    this.updateDebugInfo();
                    return;
                }

                // Execute the currently highlighted line
                this.saveExecutionState();
                this.stepCounter++;

                this.executeStep(this.parsedCode[this.currentStep]);

                // Check if next line is END FOR/END WHILE and we need to continue loop
                this.checkLoopContinuation();

                this.executionContext.waitingForExecution = false;

                // Now move to next line (recursive call)
                this.nextStep();
            }

            checkLoopContinuation() {
                // Check if the next line is END FOR or END WHILE
                const nextLineIndex = this.currentStep + 1;
                if (nextLineIndex >= this.parsedCode.length) return;

                const nextLine = this.parsedCode[nextLineIndex].trim();

                if (nextLine === 'END FOR') {
                    const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                    if (loop && loop.type === 'FOR') {
                        const currentVal = this.variables[loop.varName];
                        const stepVal = loop.stepVal || 1;
                        const nextVal = currentVal + stepVal;

                        // Check if loop should continue based on step direction
                        const shouldContinue = stepVal > 0 ?
                            nextVal <= loop.endVal :
                            nextVal >= loop.endVal;

                        if (shouldContinue) {
                            // Continue loop: apply step and jump back to FOR line
                            this.updateVariable(loop.varName, nextVal);
                            this.currentStep = loop.startLine - 1; // -1 because nextStep() will increment
                            return;
                        }
                    }
                } else if (nextLine === 'END WHILE') {
                    const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                    if (loop && loop.type === 'WHILE') {
                        // Re-evaluate the condition with fresh function calls
                        const processedCondition = this.preprocessConditionWithFunctionCalls(loop.condition);
                        const result = this.evaluateCondition(processedCondition);
                        if (result) {
                            // Continue loop: jump back to WHILE line
                            this.currentStep = loop.startLine - 1; // -1 because nextStep() will increment
                            return;
                        }
                    }
                }
            }

            executeStep(line) {
                try {
                    const trimmedLine = line.trim();
                    console.log(`[Step ${this.currentStep}] Executing: "${trimmedLine}"`); // Debug

                    // Handle main program structure
                    if (trimmedLine === 'BEGIN') {
                        // Begin main program execution - no special action needed
                        return;
                    } else if (trimmedLine === 'END') {
                        // End of main program - no special action needed
                        return;
                    }
                    // Handle function/method definitions (skip during main execution)
                    else if (trimmedLine.startsWith('FUNCTION ') || trimmedLine.startsWith('METHOD ')) {
                        // Skip function definitions during main execution
                        this.skipToEnd(trimmedLine.startsWith('FUNCTION') ? 'FUNCTION' : 'METHOD');
                        return;
                    } else if (trimmedLine.match(/^END (FUNCTION|METHOD)$/)) {
                        const endType = trimmedLine.split(' ')[1];
                        if (this.executionContext.inFunction && this.executionContext.callStack.length > 0) {
                            // We're at the end of a function or method execution
                            const callFrame = this.executionContext.callStack[this.executionContext.callStack.length - 1];
                            if (endType === 'METHOD' || (callFrame && callFrame.isMethod)) {
                                // Methods don't need explicit RETURN - auto return at END METHOD
                                this.returnFromFunction(undefined);
                            } else {
                                // Functions must have explicit RETURN statements
                                throw new Error(`Function must have explicit RETURN statement`);
                            }
                        }
                        // When not in a function/method, this is reached when skipping definitions
                        return;
                    }
                    // Handle variable assignments
                    else if (trimmedLine.includes('‚Üê') && !trimmedLine.startsWith('IF ') && !trimmedLine.startsWith('ELSE IF ') &&
                        !trimmedLine.startsWith('WHILE ') && !trimmedLine.startsWith('FOR ') &&
                        !trimmedLine.startsWith('OUTPUT ') && !trimmedLine.startsWith('PRINT ') &&
                        !trimmedLine.startsWith('FUNCTION ') && !trimmedLine.startsWith('METHOD ')) {

                        console.log('Executing assignment:', trimmedLine); // Debug
                        const parts = trimmedLine.split('‚Üê');
                        if (parts.length === 2) {
                            const varName = parts[0].trim();
                            console.log('Variable name:', varName); // Debug
                            const value = this.evaluateExpression(parts[1].trim());
                            console.log('Computed value:', value); // Debug
                            this.updateVariable(varName, value);
                            console.log('Assignment completed'); // Debug
                        }
                    } else if (trimmedLine.startsWith('OUTPUT ')) {
                        const expr = trimmedLine.substring(7);
                        const value = this.evaluateExpression(expr);
                        this.addOutput(String(value));
                    } else if (trimmedLine.startsWith('PRINT ')) {
                        const expr = trimmedLine.substring(6);
                        const value = this.evaluateExpression(expr);
                        this.addOutput(String(value));
                    } else if (trimmedLine.startsWith('IF ')) {
                        const thenIndex = trimmedLine.indexOf('THEN');
                        if (thenIndex > 0) {
                            const condition = trimmedLine.substring(3, thenIndex).trim();
                            console.log(`IF statement: evaluating condition "${condition}"`); // Debug
                            const result = this.evaluateCondition(condition);
                            console.log(`IF condition result: ${result}`); // Debug

                            this.executionContext.ifStack.push({
                                startLine: this.currentStep,
                                conditionMet: result,
                                hasExecuted: result
                            });

                            if (!result) {
                                console.log(`IF condition false, skipping to next IF block`); // Debug
                                this.skipToNextIfBlock();
                                console.log(`After skipToNextIfBlock, currentStep is now: ${this.currentStep}`); // Debug
                                // Reset waiting flag so execution can continue
                                this.executionContext.waitingForExecution = false;
                            } else {
                                console.log(`IF condition true, continuing execution`); // Debug
                            }
                        }
                    } else if (trimmedLine.startsWith('ELSE IF ')) {
                        const currentIf = this.executionContext.ifStack[this.executionContext.ifStack.length - 1];
                        if (currentIf && !currentIf.hasExecuted) {
                            const thenIndex = trimmedLine.indexOf('THEN');
                            if (thenIndex > 0) {
                                const condition = trimmedLine.substring(8, thenIndex).trim();
                                const result = this.evaluateCondition(condition);

                                if (result) {
                                    currentIf.hasExecuted = true;
                                    currentIf.conditionMet = true;
                                } else {
                                    this.skipToNextIfBlock();
                                    this.executionContext.waitingForExecution = false;
                                }
                            }
                        } else {
                            this.skipToEndIf();
                        }
                    } else if (trimmedLine === 'ELSE') {
                        const currentIf = this.executionContext.ifStack[this.executionContext.ifStack.length - 1];
                        if (currentIf && currentIf.hasExecuted) {
                            // IF block was executed, skip ELSE
                            console.log(`ELSE: IF block was executed, skipping ELSE`); // Debug
                            this.skipToEndIf();
                            this.executionContext.waitingForExecution = false;
                        } else if (currentIf) {
                            // IF block was not executed, now execute ELSE
                            console.log(`ELSE: IF block was not executed, executing ELSE`); // Debug
                            currentIf.hasExecuted = true;
                            currentIf.conditionMet = true;
                        }
                    } else if (trimmedLine === 'END IF') {
                        this.executionContext.ifStack.pop();
                    } else if (trimmedLine.startsWith('WHILE ')) {
                        const doIndex = trimmedLine.indexOf('DO');
                        if (doIndex > 0) {
                            const originalCondition = trimmedLine.substring(6, doIndex).trim();
                            const processedCondition = this.preprocessConditionWithFunctionCalls(originalCondition);
                            console.log(`WHILE condition: "${originalCondition}" ‚Üí "${processedCondition}"`); // Debug
                            const result = this.evaluateCondition(processedCondition);
                            console.log(`WHILE result: ${result}`); // Debug
                            if (result) {
                                this.executionContext.loopStacks.push({
                                    type: 'WHILE',
                                    startLine: this.currentStep,
                                    condition: originalCondition, // Store original for re-evaluation
                                    processedCondition: processedCondition
                                });
                            } else {
                                this.skipToEnd('WHILE');
                            }
                        }
                    } else if (trimmedLine === 'END WHILE') {
                        // Only reached when loop actually ends (checkLoopContinuation handles continuation)
                        const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                        if (loop && loop.type === 'WHILE') {
                            this.executionContext.loopStacks.pop();
                        }
                    } else if (trimmedLine.startsWith('FOR ')) {
                        // Match both "FOR var ‚Üê start TO end DO" and "FOR var ‚Üê start TO end STEP increment DO"
                        const match = trimmedLine.match(/FOR (\w+) ‚Üê (.+) TO (.+?)(?:\s+STEP\s+(.+?))?\s+DO/);
                        if (match) {
                            const varName = match[1];
                            // Preprocess expressions that might contain function calls
                            const startExpr = this.preprocessConditionWithFunctionCalls(match[2]);
                            const endExpr = this.preprocessConditionWithFunctionCalls(match[3]);
                            const stepExpr = match[4] ? this.preprocessConditionWithFunctionCalls(match[4]) : '1';

                            const startVal = this.evaluateExpression(startExpr);
                            const endVal = this.evaluateExpression(endExpr);
                            const stepVal = this.evaluateExpression(stepExpr);

                            // Only set the variable to startVal on the first execution (when loop is not yet in stack)
                            if (!this.executionContext.loopStacks.find(loop => loop.type === 'FOR' && loop.varName === varName)) {
                                this.updateVariable(varName, startVal);
                            }
                            // If loop is already in stack, we're continuing - don't change the variable

                            // Check if loop should execute based on current variable value and step direction
                            const currentVal = this.variables[varName];
                            const shouldExecute = stepVal > 0 ?
                                currentVal <= endVal :
                                currentVal >= endVal;

                            if (shouldExecute) {
                                // Only push to loop stack if this is the first execution
                                if (!this.executionContext.loopStacks.find(loop => loop.type === 'FOR' && loop.varName === varName)) {
                                    this.executionContext.loopStacks.push({
                                        type: 'FOR',
                                        startLine: this.currentStep,
                                        varName: varName,
                                        endVal: endVal,
                                        stepVal: stepVal
                                    });
                                }
                            } else {
                                this.skipToEnd('FOR');
                            }
                        }
                    } else if (trimmedLine === 'END FOR') {
                        // Only reached when loop actually ends (checkLoopContinuation handles continuation)
                        const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                        if (loop && loop.type === 'FOR') {
                            this.executionContext.loopStacks.pop();
                        }
                    } else if (trimmedLine.startsWith('RETURN ')) {
                        if (this.executionContext.inFunction && this.executionContext.callStack.length > 0) {
                            // Handle return from function
                            const returnExpr = trimmedLine.substring(7).trim();
                            const returnValue = this.evaluateExpression(returnExpr);
                            this.returnFromFunction(returnValue);
                        } else {
                            // Handle return statement in main program (shouldn't happen, but for safety)
                            const returnExpr = trimmedLine.substring(7).trim();
                            const returnValue = this.evaluateExpression(returnExpr);
                            this.addOutput(`RETURN: ${returnValue}`);
                            this.isRunning = false;
                        }
                    } else if (trimmedLine === 'RETURN') {
                        if (this.executionContext.inFunction && this.executionContext.callStack.length > 0) {
                            // Handle return from function without value
                            this.returnFromFunction(undefined);
                        } else {
                            // Handle return without value in main program
                            this.addOutput(`RETURN`);
                            this.isRunning = false;
                        }
                    }
                    // Handle standalone method calls (not assignments or prints)
                    else {
                        const methodCallMatch = trimmedLine.match(/^(\w+)\s*\(/);
                        if (methodCallMatch) {
                            const methodName = methodCallMatch[1];
                            if (this.executionContext.functions[methodName] &&
                                this.executionContext.functions[methodName].type === 'METHOD') {
                                // This is a standalone method call
                                this.callMethod(methodName, trimmedLine);
                            }
                        }
                    }
                } catch (error) {
                    if (error instanceof FunctionCallException) {
                        // Function call initiated - execution will continue from function
                        // Don't treat this as an error
                        return;
                    } else if (error instanceof MethodCallException) {
                        // Method call initiated - execution will continue from method
                        // Don't treat this as an error
                        return;
                    }

                    this.addOutput(`Error: ${error.message}`);
                    const currentLine = document.querySelector(`[data-line="${this.currentStep}"]`);
                    if (currentLine) {
                        currentLine.classList.add('error');
                    }
                }
            }

            skipToNextIfBlock() {
                let depth = 0;
                while (this.currentStep + 1 < this.parsedCode.length) {
                    this.currentStep++;
                    const line = this.parsedCode[this.currentStep].trim();

                    if (line.startsWith('IF ')) {
                        depth++;
                    } else if (line === 'END IF') {
                        if (depth === 0) {
                            this.currentStep--;
                            return;
                        }
                        depth--;
                    } else if (depth === 0 && (line.startsWith('ELSE IF ') || line === 'ELSE')) {
                        this.currentStep--;
                        return;
                    }
                }
            }

            skipToEndIf() {
                console.log(`skipToEndIf: Starting from line ${this.currentStep}: "${this.parsedCode[this.currentStep]}"`); // Debug
                let depth = 0;
                while (this.currentStep + 1 < this.parsedCode.length) {
                    this.currentStep++;
                    const line = this.parsedCode[this.currentStep].trim();
                    console.log(`skipToEndIf: Checking line ${this.currentStep}: "${line}" (depth: ${depth})`); // Debug

                    if (line.startsWith('IF ')) {
                        depth++;
                        console.log(`skipToEndIf: Found nested IF, depth now ${depth}`); // Debug
                    } else if (line === 'END IF') {
                        if (depth === 0) {
                            console.log(`skipToEndIf: Found matching END IF, stopping at line ${this.currentStep}`); // Debug
                            this.currentStep--;
                            return;
                        }
                        depth--;
                        console.log(`skipToEndIf: Found nested END IF, depth now ${depth}`); // Debug
                    }
                }
                console.log(`skipToEndIf: Reached end of code without finding END IF`); // Debug
            }

            skipToEnd(blockType) {
                let depth = 1;
                while (this.currentStep + 1 < this.parsedCode.length && depth > 0) {
                    this.currentStep++;
                    const line = this.parsedCode[this.currentStep];
                    
                    if (line.startsWith(blockType + ' ') || 
                        (blockType === 'IF' && line.startsWith('IF ')) ||
                        (blockType === 'WHILE' && line.startsWith('WHILE ')) ||
                        (blockType === 'FOR' && line.startsWith('FOR '))) {
                        depth++;
                    } else if (line === `END ${blockType}`) {
                        depth--;
                    }
                }
            }

            showHelp() {
                document.getElementById('helpModal').style.display = 'block';
            }

            updateButtons() {
                const startBtn = document.getElementById('startBtn');
                const nextBtn = document.getElementById('nextBtn');
                const prevBtn = document.getElementById('prevBtn');
                const autoBtn = document.getElementById('autoBtn');
                const codeInput = document.getElementById('codeInput');

                // Enable Parse & Start button if there's code in the input field or already parsed code, and not currently running
                const hasCode = (codeInput && codeInput.value.trim().length > 0) || this.parsedCode.length > 0;
                startBtn.disabled = !hasCode || this.isRunning;

                nextBtn.disabled = !this.isRunning || this.autoRunning;
                prevBtn.disabled = !this.isRunning || this.executionHistory.length === 0;
                autoBtn.disabled = this.parsedCode.length === 0;
                autoBtn.textContent = this.autoRunning ? 'Pause Auto' : 'Auto Run';
            }

            updateDebugInfo() {
                document.getElementById('stepCounter').textContent = this.stepCounter;
                document.getElementById('breakpointCount').textContent = this.breakpoints.size;
                
                let status = 'Ready';
                if (this.isRunning) {
                    if (this.autoRunning) {
                        status = 'Auto Running';
                    } else if (this.breakpoints.has(this.currentStep)) {
                        status = 'Paused at Breakpoint';
                    } else if (this.executionContext.waitingForExecution) {
                        status = 'Ready to Execute';
                    } else {
                        status = 'Running (Manual)';
                    }
                } else if (this.currentStep >= this.parsedCode.length - 1 && this.stepCounter > 0) {
                    status = 'Completed';
                }
                
                document.getElementById('executionStatus').textContent = status;
            }

        }

        // Initialize the animator when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            new MathematicalPseudocodeAnimator();
        });
    </script>
</body>
</html>