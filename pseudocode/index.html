<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Pseudocode Animator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            margin: 0;
            box-sizing: border-box;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: visible;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .speed-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(52, 152, 219, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .speed-control label {
            color: #2c3e50;
            font-weight: bold;
            font-size: 16px;
        }

        .speed-slider {
            width: 250px;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #e74c3c, #f39c12, #2ecc71);
            outline: none;
            cursor: pointer;
            appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3498db, #2980b9);
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            border: 3px solid white;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            background: linear-gradient(135deg, #2980b9, #3498db);
            transform: scale(1.2);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }

        #speedLabel {
            color: white;
            font-weight: bold;
            font-size: 16px;
            min-width: 90px;
            text-align: center;
            padding: 10px 18px;
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            border-radius: 25px;
            box-shadow: 0 3px 10px rgba(116, 185, 255, 0.3);
        }

        .content {
            display: grid;
            grid-template-columns: 2fr 2fr 1fr;
            gap: 20px;
            padding: 20px;
            min-height: 600px;
            box-sizing: border-box;
        }

        .input-panel, .pseudocode-panel, .variables-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }

        .panel-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .code-input {
            width: 100%;
            height: 400px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            resize: vertical;
            background: #fff;
            line-height: 1.5;
        }

        .code-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.2);
        }

        .validation-message {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
        }

        .validation-message.error {
            background: #fee;
            border: 1px solid #fcc;
            color: #c33;
        }

        .validation-message.success {
            background: #efe;
            border: 1px solid #cfc;
            color: #3c3;
        }

        .validation-message.warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .pseudocode-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 0;
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #333;
        }

        .pseudocode-line {
            display: flex;
            align-items: center;
            margin: 0;
            transition: all 0.3s ease;
            font-size: 14px;
            line-height: 1.4;
            min-height: 28px;
            border-left: 4px solid transparent;
        }

        .line-number {
            min-width: 40px;
            padding: 6px 8px;
            background: #2d2d2d;
            color: #858585;
            text-align: right;
            font-size: 12px;
            border-right: 1px solid #444;
            cursor: pointer;
            user-select: none;
        }

        .line-number:hover {
            background: #3d3d3d;
            color: #fff;
        }

        .line-number.breakpoint {
            background: #e74c3c;
            color: white;
        }

        .line-number.breakpoint::before {
            content: "‚óè";
            margin-right: 4px;
        }

        .line-content {
            flex: 1;
            padding: 6px 12px;
            background: #1e1e1e;
            color: #d4d4d4;
            white-space: pre;
        }

        .pseudocode-line.current {
            background: #2d4f3e;
            border-left-color: #fdcb6e;
        }

        .pseudocode-line.current .line-content {
            background: #2d4f3e;
        }

        .pseudocode-line.current .line-number {
            background: #fdcb6e;
            color: #2c3e50;
            font-weight: bold;
        }

        .pseudocode-line.completed {
            opacity: 0.6;
        }

        .pseudocode-line.completed .line-content {
            background: #1a3d2e;
        }

        .pseudocode-line.error {
            background: #4a2c2c;
            border-left-color: #e74c3c;
        }

        .pseudocode-line.error .line-content {
            background: #4a2c2c;
        }

        /* Syntax Highlighting */
        .keyword { color: #569cd6; font-weight: bold; }
        .string { color: #ce9178; }
        .number { color: #b5cea8; }
        .operator { color: #dcdcaa; }
        .variable { color: #9cdcfe; }
        .assignment { color: #d4d4d4; font-weight: bold; }
        .comment { color: #6a9955; font-style: italic; }

        .variable-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: white;
            border-radius: 8px;
            border: 2px solid #ddd;
            transition: all 0.3s ease;
        }

        .variable-item.updated {
            border-color: #e17055;
            background: #ffeaa7;
            transform: scale(1.02);
            box-shadow: 0 3px 10px rgba(225, 112, 85, 0.2);
        }

        .variable-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .variable-value {
            font-weight: bold;
            color: #e17055;
            font-size: 1.1rem;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(116, 185, 255, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7);
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(162, 155, 254, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894, #00a085);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.4);
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
        }

        .btn-info:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(23, 162, 184, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .output {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Consolas', monospace;
            min-height: 60px;
            border: 2px solid #4a5568;
        }

        .output-title {
            color: #81c784;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .examples {
            margin-top: 15px;
        }

        .example-dropdown {
            padding: 8px 12px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            min-width: 200px;
            transition: all 0.2s ease;
        }

        .example-dropdown:hover {
            background: #bbdefb;
        }

        .example-dropdown:focus {
            outline: none;
            border-color: #42a5f5;
            box-shadow: 0 0 5px rgba(66, 165, 245, 0.3);
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
        }

        .debug-info {
            background: #2c3e50;
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
        }

        .step-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 15px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        .modal-header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            margin: -20px -20px 20px -20px;
            padding: 20px;
            border-radius: 15px 15px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .close {
            color: white;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            opacity: 0.7;
        }

        .keyword-section {
            margin-bottom: 25px;
        }

        .keyword-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .keyword-item {
            background: #f8f9fa;
            margin: 8px 0;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .keyword-syntax {
            font-family: 'Consolas', monospace;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .keyword-description {
            color: #666;
            font-size: 14px;
        }

        .keyword-example {
            font-family: 'Consolas', monospace;
            background: #e8f4f8;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 13px;
            border: 1px solid #d4e6ea;
        }

        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 200px;
            }

            .speed-control {
                flex-direction: column;
                gap: 10px;
            }

            .speed-slider {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Mathematical Pseudocode Animator</h1>
            <p>Write mathematically correct pseudocode and watch it execute step by step</p>
        </div>

        <div class="controls">
            <button class="btn btn-success" id="parseBtn">Parse Code</button>
            <button class="btn btn-primary" id="startBtn" disabled>Start</button>
            <button class="btn btn-primary" id="nextBtn" disabled>Next Step</button>
            <button class="btn btn-warning" id="prevBtn" disabled>Step Back</button>
            <button class="btn btn-primary" id="autoBtn" disabled>Auto Run</button>
            <button class="btn btn-secondary" id="resetBtn">Reset</button>
            <button class="btn btn-info" id="helpBtn">üìñ Help & Keywords</button>
        </div>

        <div class="speed-control">
            <label for="speedSlider">Auto Run Speed:</label>
            <input type="range" id="speedSlider" min="1" max="10" value="5" class="speed-slider">
            <span id="speedLabel">Normal</span>
        </div>

        <div class="content">
            <div class="input-panel">
                <div class="panel-title">Write Your Pseudocode</div>
                <textarea id="codeInput" class="code-input" placeholder="Enter your pseudocode here...

Example with new structure:
BEGIN
    x ‚Üê 5
    y ‚Üê 10
    sum ‚Üê x + y
    square ‚Üê x ^ 2
    OUTPUT sum
    OUTPUT square
END

Supported commands:
‚Ä¢ BEGIN ... END (main program)
‚Ä¢ FUNCTION name ... END FUNCTION
‚Ä¢ METHOD name ... END METHOD
‚Ä¢ variable ‚Üê value
‚Ä¢ PRINT variable/value
‚Ä¢ OUTPUT variable/value
‚Ä¢ IF condition THEN ... END IF
‚Ä¢ WHILE condition DO ... END WHILE
‚Ä¢ FOR variable ‚Üê start TO end [STEP increment] DO ... END FOR

Boolean logic:
‚Ä¢ AND, OR for combining conditions
‚Ä¢ Use parentheses for grouping: (x > 5 AND y < 10) OR z = 0

Use ‚Üê for assignment, = for equality, ^ for powers
Click line numbers to set breakpoints!"></textarea>
                <div id="validationMessage" class="validation-message"></div>
                
                <div class="examples">
                    <label for="exampleSelect" style="font-weight: bold; margin-right: 8px; color: #2c3e50;">Quick Examples:</label>
                    <select id="exampleSelect" class="example-dropdown">
                        <option value="">-- Select an example --</option>
                        <option value="simple">Simple Calculation</option>
                        <option value="power">Powers & Exponents</option>
                        <option value="loop">While Loop</option>
                        <option value="factorial">Factorial</option>
                        <option value="squares">Square Numbers</option>
                        <option value="logical">Logical Operators (AND/OR)</option>
                        <option value="functions">Functions</option>
                        <option value="methods">Methods</option>
                        <option value="steps">FOR Loops with Steps</option>
                    </select>
                </div>
                
                <div class="help-text">
                    <strong>Instructions:</strong> Click line numbers to set breakpoints. Use Step Back to undo steps. 
                    Syntax highlighting shows different code elements in color.
                </div>
            </div>

            <div class="pseudocode-panel">
                <div class="panel-title">Processed Code</div>
                <div class="pseudocode-container" id="pseudocode"></div>
                
                <div class="debug-info">
                    <div class="step-info">
                        <span>Step: <span id="stepCounter">0</span></span>
                        <span>Breakpoints: <span id="breakpointCount">0</span></span>
                    </div>
                    <div>Status: <span id="executionStatus">Ready</span></div>
                </div>
                
                <div class="output">
                    <div class="output-title">Output:</div>
                    <div id="output"></div>
                </div>
            </div>

            <div class="variables-panel">
                <div class="panel-title">Variables</div>
                <div id="variables"></div>
            </div>
        </div>

        <!-- Help Modal -->
        <div id="helpModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <span class="close">&times;</span>
                    <h2>Mathematical Pseudocode Syntax Guide</h2>
                </div>

                <div class="keyword-section">
                    <h3>New Features</h3>
                    
                    <div class="keyword-item">
                        <div class="keyword-syntax">Boolean Logic (AND/OR)</div>
                        <div class="keyword-description">Combine multiple conditions using AND and OR operators. Use parentheses for grouping.</div>
                        <div class="keyword-example">IF x > 5 AND y < 10 THEN<br>IF a = 1 OR b = 2 THEN<br>IF (x > 0 AND y > 0) OR z = 0 THEN</div>
                    </div>
                    
                    <div class="keyword-item">
                        <div class="keyword-syntax">Breakpoints</div>
                        <div class="keyword-description">Click on line numbers to set/remove breakpoints. Execution will pause BEFORE executing the breakpoint line.</div>
                        <div class="keyword-example">Click the gray line number ‚Üí Red dot appears ‚Üí Execution pauses before that line</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Step Back</div>
                        <div class="keyword-description">Undo the last execution step to review what happened.</div>
                        <div class="keyword-example">Use "Step Back" button to reverse the last operation</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Syntax Highlighting</div>
                        <div class="keyword-description">Different parts of code are colored: keywords (blue), strings (orange), numbers (green), operators (yellow).</div>
                        <div class="keyword-example">IF (blue) x (cyan) ‚Üê (white) 5 (green) THEN (blue)</div>
                    </div>
                </div>

                <div class="keyword-section">
                    <h3>Mathematical Operators</h3>
                    
                    <div class="keyword-item">
                        <div class="keyword-syntax">Assignment vs Equality vs Power</div>
                        <div class="keyword-description">‚Üê for assignment, = for equality testing, ^ for exponentiation</div>
                        <div class="keyword-example">x ‚Üê 5 (assignment)<br>IF x = 5 THEN (equality)<br>area ‚Üê x ^ 2 (power)</div>
                    </div>

                    <div class="keyword-item">
                        <div class="keyword-syntax">Arithmetic Operators</div>
                        <div class="keyword-description">+ (add), - (subtract), * (multiply), / (divide), ^ (power)</div>
                        <div class="keyword-example">result ‚Üê 2 + 3 * 4<br>area ‚Üê pi * radius ^ 2<br>compound ‚Üê principal * (1 + rate) ^ years</div>
                    </div>
                </div>

                <div class="keyword-section">
                    <h3>Control Structures</h3>
                    
                    <div class="keyword-item">
                        <div class="keyword-syntax">FOR variable ‚Üê start TO end [STEP increment] DO<br>&nbsp;&nbsp;&nbsp;&nbsp;statements<br>END FOR</div>
                        <div class="keyword-description">Repeats statements with counter from start to end. STEP is optional (default 1). Use negative step to count backwards.</div>
                        <div class="keyword-example">FOR i ‚Üê 1 TO 10 STEP 2 DO<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT i<br>END FOR<br><br>FOR i ‚Üê 10 TO 1 STEP -1 DO<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINT i<br>END FOR</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Special exception for function calls that need step-through execution
        class FunctionCallException extends Error {
            constructor(functionName) {
                super(`Function call: ${functionName}`);
                this.name = 'FunctionCallException';
                this.functionName = functionName;
            }
        }

        // Special exception for method calls that need step-through execution
        class MethodCallException extends Error {
            constructor(methodName) {
                super(`Method call: ${methodName}`);
                this.name = 'MethodCallException';
                this.methodName = methodName;
            }
        }

        class MathematicalPseudocodeAnimator {
            constructor() {
                this.currentStep = -1;
                this.isRunning = false;
                this.autoRunning = false;
                this.variables = {};
                this.output = [];
                this.parsedCode = [];
                this.executionContext = { loopStacks: [], ifStack: [], breakpointPaused: false };
                this.autoRunSpeed = 5;
                this.breakpoints = new Set();
                this.executionHistory = [];
                this.stepCounter = 0;
                
                this.examples = {
                    simple: 'BEGIN\n    x ‚Üê 5\n    y ‚Üê 10\n    sum ‚Üê x + y\n    PRINT "Sum: " + sum\nEND',
                    power: 'BEGIN\n    base ‚Üê 3\n    exponent ‚Üê 4\n    result ‚Üê base ^ exponent\n    PRINT base + " to the power of " + exponent + " = " + result\nEND',
                    squares: 'BEGIN\n    FOR i ‚Üê 1 TO 5 DO\n        square ‚Üê i ^ 2\n        PRINT "Square of " + i + " is " + square\n    END FOR\nEND',
                    loop: 'BEGIN\n    count ‚Üê 0\n    total ‚Üê 0\n    WHILE count < 5 DO\n        total ‚Üê total + count\n        count ‚Üê count + 1\n    END WHILE\n    PRINT "Total: " + total\nEND',
                    factorial: 'BEGIN\n    n ‚Üê 5\n    factorial ‚Üê 1\n    i ‚Üê 1\n    WHILE i <= n DO\n        factorial ‚Üê factorial * i\n        i ‚Üê i + 1\n    END WHILE\n    PRINT "Factorial of " + n + " is " + factorial\nEND',
                    logical: 'BEGIN\n    x ‚Üê 7\n    y ‚Üê 3\n    z ‚Üê 0\n    \n    IF x > 5 AND y < 10 THEN\n        PRINT "Both conditions met"\n    END IF\n    \n    IF x < 5 OR y < 5 THEN\n        PRINT "At least one is less than 5"\n    END IF\n    \n    IF (x > 0 AND y > 0) OR z = 0 THEN\n        PRINT "Complex condition is true"\n    END IF\nEND',
                    functions: 'FUNCTION square(x)\n    result ‚Üê x * x\n    RETURN result\nEND FUNCTION\n\nFUNCTION add(a, b)\n    RETURN a + b\nEND FUNCTION\n\nBEGIN\n    num ‚Üê 5\n    sq ‚Üê square(num)\n    doubled ‚Üê add(sq, sq)\n    PRINT "Square of " + num + " is " + sq\n    PRINT "Double the square is " + doubled\nEND',
                    methods: 'METHOD printGreeting(name)\n    PRINT "Hello, " + name + "!"\nEND METHOD\n\nMETHOD showInfo(value, label)\n    PRINT label + ": " + value\nEND METHOD\n\nBEGIN\n    username ‚Üê "Alice"\n    age ‚Üê 25\n    printGreeting(username)\n    showInfo(age, "Age")\n    showInfo(username, "Name")\nEND',
                    steps: 'BEGIN\n    PRINT "Odd numbers from 1 to 10:"\n    FOR i ‚Üê 1 TO 10 STEP 2 DO\n        PRINT i\n    END FOR\n    \n    PRINT "Countdown from 10 to 0:"\n    FOR i ‚Üê 10 TO 0 STEP -1 DO\n        PRINT i\n    END FOR\n    \n    PRINT "Multiples of 3 from 0 to 15:"\n    FOR i ‚Üê 0 TO 15 STEP 3 DO\n        PRINT i\n    END FOR\nEND'
                };
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('parseBtn').addEventListener('click', () => this.parseCode());
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('nextBtn').addEventListener('click', () => this.nextStep());
                document.getElementById('prevBtn').addEventListener('click', () => this.stepBack());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('autoBtn').addEventListener('click', () => this.toggleAutoRun());
                document.getElementById('helpBtn').addEventListener('click', () => this.showHelp());
                
                const codeInput = document.getElementById('codeInput');
                codeInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const start = codeInput.selectionStart;
                        const end = codeInput.selectionEnd;
                        const value = codeInput.value;
                        codeInput.value = value.substring(0, start) + '    ' + value.substring(end);
                        codeInput.selectionStart = codeInput.selectionEnd = start + 4;
                    }
                });
                
                const modal = document.getElementById('helpModal');
                document.querySelector('.close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
                window.addEventListener('click', (e) => {
                    if (e.target === modal) modal.style.display = 'none';
                });
                
                document.getElementById('exampleSelect').addEventListener('change', (e) => {
                    const example = e.target.value;
                    if (example && this.examples[example]) {
                        document.getElementById('codeInput').value = this.examples[example];
                        this.parseCode();
                        // Reset the dropdown to show placeholder
                        e.target.value = '';
                    }
                });

                const speedSlider = document.getElementById('speedSlider');
                speedSlider.addEventListener('input', (e) => {
                    this.autoRunSpeed = parseInt(e.target.value);
                    this.updateSpeedLabel();
                });
                this.updateSpeedLabel();
            }

            parseCode() {
                let rawInput = document.getElementById('codeInput').value;
                rawInput = rawInput.replace(/\^/g, '**');
                
                const lines = rawInput.split('\n')
                    .map(line => line.trimEnd()) // Only trim trailing whitespace, preserve indentation
                    .filter(line => line.trim().length > 0) // Filter out completely empty lines
                    .map(line => {
                        line = line.replace(/<-/g, '‚Üê');
                        // Normalize spacing around ‚Üê operator: ensure single space on both sides
                        line = line.replace(/\s*‚Üê\s*/g, ' ‚Üê ');
                        line = line.replace(/\b(if|then|else|elseif|end|while|do|for|to|output|print|input|and|or|begin|function|method|return|call)\b/gi,
                            match => match.toUpperCase());
                        return line;
                    });

                const validation = this.validateCode(lines);
                const messageDiv = document.getElementById('validationMessage');
                
                if (validation.errors.length > 0) {
                    messageDiv.className = 'validation-message error';
                    messageDiv.style.display = 'block';
                    messageDiv.innerHTML = '<strong>Errors:</strong><br>' + validation.errors.join('<br>');
                    this.parsedCode = [];
                    this.renderParsedCode();
                    this.updateButtons();
                    return;
                }
                
                messageDiv.className = 'validation-message success';
                messageDiv.style.display = 'block';
                messageDiv.innerHTML = '<strong>‚úî Code parsed successfully!</strong>';
                
                this.parsedCode = lines;
                this.breakpoints.clear();
                this.executionHistory = [];
                this.stepCounter = 0;
                this.renderParsedCode();
                this.initializeVariables();
                this.updateButtons();
                this.updateDebugInfo();
                
                setTimeout(() => messageDiv.style.display = 'none', 3000);
            }

            validateCode(lines) {
                const errors = [];
                const blockStack = [];
                let hasBegin = false;
                let hasEnd = false;
                let inMainCode = false;
                let functionCount = 0;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmedLine = line.trim(); // Use trimmed version for validation
                    const lineNum = i + 1;

                    // Check for main code structure
                    if (trimmedLine === 'BEGIN') {
                        if (hasBegin) {
                            errors.push(`Line ${lineNum}: Multiple BEGIN statements not allowed`);
                        }
                        hasBegin = true;
                        inMainCode = true;
                        blockStack.push('BEGIN');
                    } else if (trimmedLine === 'END') {
                        if (!hasBegin) {
                            errors.push(`Line ${lineNum}: END without BEGIN`);
                        } else if (blockStack[blockStack.length - 1] !== 'BEGIN') {
                            errors.push(`Line ${lineNum}: END must close BEGIN, not ${blockStack[blockStack.length - 1]}`);
                        } else {
                            hasEnd = true;
                            inMainCode = false;
                            blockStack.pop();
                        }
                    }
                    // Check for function/method definitions
                    else if (trimmedLine.startsWith('FUNCTION ') || trimmedLine.startsWith('METHOD ')) {
                        if (inMainCode) {
                            errors.push(`Line ${lineNum}: Functions/methods must be defined outside the main BEGIN/END block`);
                        }
                        const match = trimmedLine.match(/^(FUNCTION|METHOD)\s+(\w+)\s*(\([^)]*\))?\s*$/);
                        if (!match) {
                            errors.push(`Line ${lineNum}: Invalid function/method syntax. Use 'FUNCTION name' or 'FUNCTION name(params)'`);
                        }
                        blockStack.push(trimmedLine.startsWith('FUNCTION') ? 'FUNCTION' : 'METHOD');
                        functionCount++;
                    }
                    // Check for existing block structures
                    else if (trimmedLine.includes('‚Üê') && !trimmedLine.startsWith('IF ') && !trimmedLine.startsWith('ELSE IF ') &&
                        !trimmedLine.startsWith('WHILE ') && !trimmedLine.startsWith('FOR ') &&
                        !trimmedLine.startsWith('OUTPUT ') && !trimmedLine.startsWith('PRINT ') &&
                        !trimmedLine.startsWith('FUNCTION ') && !trimmedLine.startsWith('METHOD ')) {
                        const parts = trimmedLine.split('‚Üê');
                        if (parts.length !== 2 || parts[0].trim() === '' || parts[1].trim() === '') {
                            errors.push(`Line ${lineNum}: Invalid assignment format`);
                        }
                    } else if (trimmedLine.startsWith('IF ')) {
                        if (!trimmedLine.includes('THEN')) errors.push(`Line ${lineNum}: IF must end with THEN`);
                        blockStack.push('IF');
                    } else if (trimmedLine.startsWith('WHILE ')) {
                        if (!trimmedLine.includes('DO')) errors.push(`Line ${lineNum}: WHILE must end with DO`);
                        blockStack.push('WHILE');
                    } else if (trimmedLine.startsWith('FOR ')) {
                        if (!trimmedLine.includes('‚Üê') || !trimmedLine.includes('TO') || !trimmedLine.includes('DO')) {
                            errors.push(`Line ${lineNum}: FOR must be 'FOR var ‚Üê start TO end [STEP increment] DO'`);
                        }
                        blockStack.push('FOR');
                    } else if (trimmedLine.match(/^END (IF|WHILE|FOR|FUNCTION|METHOD)$/)) {
                        const endType = trimmedLine.split(' ')[1];
                        if (blockStack.length === 0) {
                            errors.push(`Line ${lineNum}: Unexpected END statement`);
                        } else {
                            const expectedEnd = blockStack[blockStack.length - 1];
                            if (expectedEnd !== endType) {
                                errors.push(`Line ${lineNum}: Expected END ${expectedEnd}, found END ${endType}`);
                            } else {
                                blockStack.pop();
                            }
                        }
                    }
                }

                // Check for required BEGIN/END structure
                if (!hasBegin) {
                    errors.push("Main code must be enclosed in BEGIN...END block");
                }
                if (hasBegin && !hasEnd) {
                    errors.push("BEGIN block must be closed with END");
                }

                if (blockStack.length > 0) {
                    errors.push(`Missing END statements for: ${blockStack.join(', ')}`);
                }

                return { errors };
            }

            applySyntaxHighlighting(line, lineElement) {
                lineElement.innerHTML = '';
                const tokens = this.tokenizeLine(line);
                
                tokens.forEach(token => {
                    const span = document.createElement('span');
                    span.textContent = token.text;
                    span.className = token.type;
                    lineElement.appendChild(span);
                });
            }

            tokenizeLine(line) {
                const tokens = [];
                let i = 0;
                
                while (i < line.length) {
                    if (line[i] === ' ') {
                        let spaces = '';
                        while (i < line.length && line[i] === ' ') {
                            spaces += line[i];
                            i++;
                        }
                        tokens.push({ text: spaces, type: '' });
                        continue;
                    }
                    
                    if (line[i] === '"') {
                        let str = '"';
                        i++;
                        while (i < line.length && line[i] !== '"') {
                            str += line[i];
                            i++;
                        }
                        if (i < line.length) str += line[i++];
                        tokens.push({ text: str, type: 'string' });
                        continue;
                    }
                    
                    if (/\d/.test(line[i])) {
                        let num = '';
                        while (i < line.length && /[\d.]/.test(line[i])) {
                            num += line[i];
                            i++;
                        }
                        tokens.push({ text: num, type: 'number' });
                        continue;
                    }
                    
                    if (line[i] === '‚Üê') {
                        tokens.push({ text: '‚Üê', type: 'assignment' });
                        i++;
                        continue;
                    }
                    
                    if (line.substr(i, 2) === '**') {
                        tokens.push({ text: '**', type: 'operator' });
                        i += 2;
                        continue;
                    }
                    
                    if (/[+\-*/><=()]/.test(line[i])) {
                        if (i + 1 < line.length && line.substr(i, 2).match(/>=|<=/)) {
                            tokens.push({ text: line.substr(i, 2), type: 'operator' });
                            i += 2;
                        } else {
                            tokens.push({ text: line[i], type: 'operator' });
                            i++;
                        }
                        continue;
                    }
                    
                    if (/[a-zA-Z_]/.test(line[i])) {
                        let word = '';
                        while (i < line.length && /[a-zA-Z0-9_]/.test(line[i])) {
                            word += line[i];
                            i++;
                        }
                        
                        const keywords = ['IF', 'THEN', 'ELSE', 'ELSEIF', 'END', 'WHILE', 'DO', 'FOR', 'TO', 'STEP', 'OUTPUT', 'PRINT', 'INPUT', 'AND', 'OR', 'BEGIN', 'FUNCTION', 'METHOD', 'RETURN', 'CALL'];
                        const type = keywords.includes(word) ? 'keyword' : 'variable';
                        tokens.push({ text: word, type });
                        continue;
                    }
                    
                    tokens.push({ text: line[i], type: '' });
                    i++;
                }
                
                return tokens;
            }

            renderParsedCode() {
                const pseudocodeDiv = document.getElementById('pseudocode');
                if (this.parsedCode.length === 0) {
                    pseudocodeDiv.innerHTML = '<div style="color: #999; font-style: italic; padding: 20px;">No valid code to display</div>';
                    return;
                }

                pseudocodeDiv.innerHTML = '';

                this.parsedCode.forEach((line, index) => {
                    
                    const isBreakpoint = this.breakpoints.has(index);
                    
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'pseudocode-line';
                    lineDiv.dataset.line = index;
                    
                    const lineNumDiv = document.createElement('div');
                    lineNumDiv.className = `line-number ${isBreakpoint ? 'breakpoint' : ''}`;
                    lineNumDiv.dataset.line = index;
                    lineNumDiv.textContent = index + 1;
                    lineNumDiv.addEventListener('click', (e) => {
                        const lineIndex = parseInt(e.target.dataset.line);
                        this.toggleBreakpoint(lineIndex);
                    });
                    
                    const lineContentDiv = document.createElement('div');
                    lineContentDiv.className = 'line-content';

                    this.applySyntaxHighlighting(line, lineContentDiv); // Use original line with preserved indentation
                    
                    lineDiv.appendChild(lineNumDiv);
                    lineDiv.appendChild(lineContentDiv);
                    pseudocodeDiv.appendChild(lineDiv);
                });
            }

            toggleBreakpoint(lineIndex) {
                if (this.breakpoints.has(lineIndex)) {
                    this.breakpoints.delete(lineIndex);
                } else {
                    this.breakpoints.add(lineIndex);
                }
                this.renderParsedCode();
                this.updateDebugInfo();
            }

            saveExecutionState() {
                this.executionHistory.push({
                    step: this.currentStep,
                    variables: JSON.parse(JSON.stringify(this.variables)),
                    output: [...this.output],
                    executionContext: JSON.parse(JSON.stringify(this.executionContext)),
                    stepCounter: this.stepCounter
                });
            }

            stepBack() {
                if (this.executionHistory.length === 0) return;
                
                const previousState = this.executionHistory.pop();
                this.currentStep = previousState.step;
                this.variables = previousState.variables;
                this.output = previousState.output;
                this.executionContext = previousState.executionContext;
                this.stepCounter = previousState.stepCounter;
                
                this.renderVariables();
                this.renderOutput();
                this.highlightLine(this.currentStep);
                this.updateButtons();
                this.updateDebugInfo();
            }

            initializeVariables() {
                this.variables = {};
                this.renderVariables();
                this.clearOutput();
            }

            renderVariables() {
                const variablesDiv = document.getElementById('variables');
                if (Object.keys(this.variables).length === 0) {
                    variablesDiv.innerHTML = '<div style="color: #999; font-style: italic;">No variables defined yet</div>';
                    return;
                }
                
                variablesDiv.innerHTML = Object.entries(this.variables).map(([name, value]) => 
                    `<div class="variable-item" data-var="${name}">
                        <span class="variable-name">${name}:</span>
                        <span class="variable-value">${this.formatValue(value)}</span>
                    </div>`
                ).join('');
            }

            formatValue(value) {
                if (Array.isArray(value)) return `[${value.join(', ')}]`;
                if (typeof value === 'string') return `"${value}"`;
                return String(value);
            }

            updateVariable(name, value, highlight = true) {
                this.variables[name] = value;
                this.renderVariables();
                if (highlight) {
                    const varItem = document.querySelector(`[data-var="${name}"]`);
                    if (varItem) {
                        varItem.classList.add('updated');
                        setTimeout(() => varItem.classList.remove('updated'), 1000);
                    }
                }
            }

            evaluateExpression(expr) {
                expr = expr.trim();

                // Check for function calls first
                const funcCallMatch = expr.match(/^(\w+)\s*\(([^)]*)\)$/);
                if (funcCallMatch) {
                    const funcName = funcCallMatch[1];
                    const argsStr = funcCallMatch[2];
                    return this.callFunction(funcName, argsStr);
                }

                // Check for function calls in complex expressions (like x + func(y))
                if (expr.includes('(') && expr.includes(')')) {
                    // Replace function calls with their return values
                    expr = expr.replace(/(\w+)\s*\(([^)]*)\)/g, (match, funcName, argsStr) => {
                        if (this.executionContext.functions && this.executionContext.functions[funcName]) {
                            return this.callFunction(funcName, argsStr);
                        }
                        return match; // Not a function call, leave as is
                    });
                }

                if (expr.includes('+') && (expr.includes('"') || expr.includes("'"))) {
                    return this.evaluateStringExpression(expr);
                }

                if (expr.includes('[') && expr.includes(']')) {
                    const match = expr.match(/(\w+)\[(.+)\]/);
                    if (match) {
                        const arrayName = match[1];
                        const indexExpr = match[2];
                        const index = this.evaluateExpression(indexExpr);
                        return this.variables[arrayName] ? this.variables[arrayName][index] : undefined;
                    }
                }
                
                if (/^\w+$/.test(expr) && this.variables.hasOwnProperty(expr)) {
                    return this.variables[expr];
                }
                
                if (/^-?\d+(\.\d+)?$/.test(expr)) {
                    return parseFloat(expr);
                }
                
                if ((expr.startsWith('"') && expr.endsWith('"')) || 
                    (expr.startsWith("'") && expr.endsWith("'"))) {
                    return expr.slice(1, -1);
                }
                
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const content = expr.slice(1, -1).trim();
                    if (content === '') return [];
                    return content.split(',').map(item => this.evaluateExpression(item.trim()));
                }
                
                return this.evaluateArithmetic(expr);
            }

            callFunction(funcName, argsStr) {
                // Check if function exists
                if (!this.executionContext.functions || !this.executionContext.functions[funcName]) {
                    throw new Error(`Function '${funcName}' is not defined`);
                }

                const func = this.executionContext.functions[funcName];

                // Parse arguments
                const args = argsStr.trim() ? argsStr.split(',').map(arg => this.evaluateExpression(arg.trim())) : [];

                // Check parameter count
                if (args.length !== func.params.length) {
                    throw new Error(`Function '${funcName}' expects ${func.params.length} arguments, got ${args.length}`);
                }

                // Check if we're returning from this function call
                if (this.executionContext.pendingReturn &&
                    this.executionContext.pendingReturn.functionName === funcName) {
                    const returnValue = this.executionContext.pendingReturn.returnValue;
                    this.executionContext.pendingReturn = null;
                    console.log(`Function ${funcName} returning value:`, returnValue); // Debug
                    return returnValue;
                }

                // Initiate the function call for step-by-step execution
                this.initiateFunctionCall(funcName, args, func);

                // Throw a special exception to pause execution and jump to function
                throw new FunctionCallException(funcName);
            }

            callMethod(methodName, fullLine) {
                // Check if method exists
                if (!this.executionContext.functions || !this.executionContext.functions[methodName]) {
                    throw new Error(`Method '${methodName}' is not defined`);
                }

                const method = this.executionContext.functions[methodName];

                // Ensure it's actually a method
                if (method.type !== 'METHOD') {
                    throw new Error(`'${methodName}' is not a method`);
                }

                // Parse arguments from the full line
                const argsMatch = fullLine.match(/\(([^)]*)\)/);
                const argsStr = argsMatch ? argsMatch[1] : '';
                const args = argsStr.trim() ? argsStr.split(',').map(arg => this.evaluateExpression(arg.trim())) : [];

                // Check parameter count
                if (args.length !== method.params.length) {
                    throw new Error(`Method '${methodName}' expects ${method.params.length} arguments, got ${args.length}`);
                }

                // Check if we're returning from this method call
                if (this.executionContext.pendingReturn &&
                    this.executionContext.pendingReturn.functionName === methodName) {
                    // Method execution completed, clear pending return and continue
                    this.executionContext.pendingReturn = null;
                    console.log(`Method ${methodName} completed`); // Debug
                    return;
                }

                // Initiate the method call for step-by-step execution
                this.initiateMethodCall(methodName, args, method);

                // Throw a special exception to pause execution and jump to method
                throw new MethodCallException(methodName);
            }

            initiateFunctionCall(funcName, args, func) {
                // Save current execution state to call stack
                const callFrame = {
                    functionName: funcName,
                    returnLine: this.currentStep,
                    returnVariables: JSON.parse(JSON.stringify(this.variables)),
                    waitingForExecution: this.executionContext.waitingForExecution,
                    returnValue: undefined
                };

                this.executionContext.callStack.push(callFrame);

                // Set up function parameters as local variables (clear all globals)
                this.variables = {};
                for (let i = 0; i < func.params.length; i++) {
                    this.variables[func.params[i]] = args[i];
                }

                // Jump to function start (skip the FUNCTION declaration line)
                this.currentStep = func.startLine;
                this.executionContext.waitingForExecution = true;
                this.executionContext.inFunction = true;

                // Render variables to show the new local scope
                this.renderVariables();
            }

            initiateMethodCall(methodName, args, method) {
                // Save current execution state to call stack
                const callFrame = {
                    functionName: methodName, // Use same property name for consistency
                    returnLine: this.currentStep,
                    returnVariables: JSON.parse(JSON.stringify(this.variables)),
                    waitingForExecution: this.executionContext.waitingForExecution,
                    returnValue: undefined,
                    isMethod: true // Flag to distinguish from function calls
                };

                this.executionContext.callStack.push(callFrame);

                // Set up method parameters as local variables (clear all globals)
                this.variables = {};
                for (let i = 0; i < method.params.length; i++) {
                    this.variables[method.params[i]] = args[i];
                }

                // Jump to method start (skip the METHOD declaration line)
                this.currentStep = method.startLine;
                this.executionContext.waitingForExecution = true;
                this.executionContext.inFunction = true; // Reuse the same flag

                // Render variables to show the new local scope
                this.renderVariables();
            }

            returnFromFunction(returnValue) {
                console.log('Returning from function with value:', returnValue); // Debug

                // Pop the call frame from the stack
                const callFrame = this.executionContext.callStack.pop();

                if (callFrame) {
                    console.log('Restoring to line:', callFrame.returnLine); // Debug
                    console.log('Function name:', callFrame.functionName); // Debug

                    // Restore the previous execution state
                    this.currentStep = callFrame.returnLine;
                    this.variables = callFrame.returnVariables;
                    this.executionContext.inFunction = this.executionContext.callStack.length > 0;

                    // Set up the return value to be used when the line is re-executed
                    this.executionContext.pendingReturn = {
                        functionName: callFrame.functionName,
                        returnValue: returnValue
                    };

                    console.log('Set pendingReturn:', this.executionContext.pendingReturn); // Debug

                    // Update the UI to reflect the restored state
                    this.renderVariables();

                    // Set up for re-execution of the calling line
                    this.executionContext.waitingForExecution = true;

                    // Highlight the calling line again
                    this.highlightLine(this.currentStep);
                    this.updateButtons();
                    this.updateDebugInfo();
                }
            }

            evaluateStringExpression(expr) {
                const parts = expr.split('+');
                let result = '';
                for (const part of parts) {
                    const value = this.evaluateExpression(part.trim());
                    result += String(value);
                }
                return result;
            }

            evaluateArithmetic(expr) {
                let processedExpr = expr;
                
                const sortedVars = Object.keys(this.variables).sort((a, b) => b.length - a.length);
                for (const name of sortedVars) {
                    const value = this.variables[name];
                    if (typeof value === 'number') {
                        processedExpr = processedExpr.replace(new RegExp(`\\b${name}\\b`, 'g'), `(${value})`);
                    }
                }
                
                try {
                    return Function(`"use strict"; return (${processedExpr})`)();
                } catch (e) {
                    console.log('Arithmetic error:', e, 'Expression:', processedExpr);
                    return 0;
                }
            }

            evaluateCondition(condition) {
                condition = condition.trim();
                condition = condition.replace(/‚â•/g, '>=').replace(/‚â§/g, '<=');
                
                // Handle parentheses recursively
                while (condition.includes('(')) {
                    condition = condition.replace(/\([^()]+\)/g, (match) => {
                        const inner = match.slice(1, -1);
                        return this.evaluateCondition(inner) ? 'TRUE' : 'FALSE';
                    });
                }
                
                // Handle OR operator (lower precedence)
                if (condition.includes(' OR ')) {
                    const parts = condition.split(' OR ');
                    for (const part of parts) {
                        if (this.evaluateCondition(part.trim())) {
                            return true;
                        }
                    }
                    return false;
                }
                
                // Handle AND operator (higher precedence)
                if (condition.includes(' AND ')) {
                    const parts = condition.split(' AND ');
                    for (const part of parts) {
                        if (!this.evaluateCondition(part.trim())) {
                            return false;
                        }
                    }
                    return true;
                }
                
                // Handle boolean literals from parentheses evaluation
                if (condition === 'TRUE') return true;
                if (condition === 'FALSE') return false;
                
                // Handle simple comparisons
                const operators = ['>=', '<=', '>', '<', '='];
                for (const op of operators) {
                    if (condition.includes(op)) {
                        const parts = condition.split(op);
                        if (parts.length === 2) {
                            const leftVal = this.evaluateExpression(parts[0].trim());
                            const rightVal = this.evaluateExpression(parts[1].trim());
                            
                            switch (op) {
                                case '>=': return leftVal >= rightVal;
                                case '<=': return leftVal <= rightVal;
                                case '>': return leftVal > rightVal;
                                case '<': return leftVal < rightVal;
                                case '=': return leftVal == rightVal;
                            }
                        }
                    }
                }
                return false;
            }

            highlightLine(lineIndex) {
                document.querySelectorAll('.pseudocode-line').forEach((line, index) => {
                    line.classList.remove('current', 'completed', 'error');
                    if (index < lineIndex) {
                        line.classList.add('completed');
                    } else if (index === lineIndex) {
                        line.classList.add('current');
                        // Auto-scroll to keep the current line visible
                        this.scrollToLine(line);
                    }
                });
            }

            scrollToLine(lineElement) {
                const codeContainer = document.getElementById('pseudocode');
                if (!codeContainer || !lineElement) return;

                const containerRect = codeContainer.getBoundingClientRect();
                const lineRect = lineElement.getBoundingClientRect();

                // Check if line is above the visible area
                if (lineRect.top < containerRect.top) {
                    // Scroll up to show the line with some padding
                    lineElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
                // Check if line is below the visible area
                else if (lineRect.bottom > containerRect.bottom) {
                    // Scroll down to show the line with some padding
                    lineElement.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
                // If line is partially visible or needs centering for better visibility
                else if (lineRect.top < containerRect.top + 50 || lineRect.bottom > containerRect.bottom - 50) {
                    // Center the line in the view for better visibility
                    lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            addOutput(text) {
                this.output.push(text);
                this.renderOutput();
            }

            renderOutput() {
                document.getElementById('output').innerHTML = this.output.join('<br>');
            }

            clearOutput() {
                this.output = [];
                this.renderOutput();
            }

            start() {
                if (this.parsedCode.length === 0) {
                    alert('Please parse your code first!');
                    return;
                }

                // Find the BEGIN statement to start main program execution
                let beginIndex = -1;
                for (let i = 0; i < this.parsedCode.length; i++) {
                    if (this.parsedCode[i].trim() === 'BEGIN') {
                        beginIndex = i;
                        break;
                    }
                }

                if (beginIndex === -1) {
                    alert('No BEGIN statement found! Main code must be enclosed in BEGIN...END.');
                    return;
                }

                this.isRunning = true;
                this.currentStep = beginIndex - 1; // Start just before BEGIN so nextStep() lands on BEGIN
                this.stepCounter = 0;
                this.executionContext = {
                    loopStacks: [],
                    ifStack: [],
                    breakpointPaused: false,
                    waitingForExecution: false,
                    functions: this.parseFunctions(),
                    callStack: [],
                    inFunction: false,
                    pendingReturn: null
                };
                this.executionHistory = [];
                this.initializeVariables();
                this.updateButtons();
                this.updateDebugInfo();
                this.nextStep();
            }

            parseFunctions() {
                const functions = {};
                let i = 0;

                while (i < this.parsedCode.length) {
                    const line = this.parsedCode[i];
                    const trimmedLine = line.trim();

                    if (trimmedLine.startsWith('FUNCTION ') || trimmedLine.startsWith('METHOD ')) {
                        const match = trimmedLine.match(/^(FUNCTION|METHOD)\s+(\w+)\s*(\([^)]*\))?\s*$/);
                        if (match) {
                            const type = match[1];
                            const name = match[2];
                            const params = match[3] ? match[3].slice(1, -1).split(',').map(p => p.trim()).filter(p => p) : [];

                            const startLine = i;
                            let endLine = -1;
                            let depth = 1;

                            // Find the corresponding END FUNCTION/METHOD
                            for (let j = i + 1; j < this.parsedCode.length; j++) {
                                const nextLine = this.parsedCode[j].trim();
                                if (nextLine.startsWith('FUNCTION ') || nextLine.startsWith('METHOD ')) {
                                    depth++;
                                } else if (nextLine === `END ${type}`) {
                                    depth--;
                                    if (depth === 0) {
                                        endLine = j;
                                        break;
                                    }
                                }
                            }

                            if (endLine !== -1) {
                                functions[name] = {
                                    type: type,
                                    params: params,
                                    startLine: startLine,
                                    endLine: endLine,
                                    body: this.parsedCode.slice(startLine + 1, endLine)
                                };
                            }

                            i = endLine + 1;
                        } else {
                            i++;
                        }
                    } else {
                        i++;
                    }
                }

                return functions;
            }

            reset() {
                this.isRunning = false;
                this.autoRunning = false;
                this.currentStep = -1;
                this.stepCounter = 0;
                this.executionContext = { loopStacks: [], ifStack: [], breakpointPaused: false, waitingForExecution: false, callStack: [], inFunction: false, pendingReturn: null };
                this.executionHistory = [];
                this.initializeVariables();
                this.updateButtons();
                this.updateDebugInfo();
                document.querySelectorAll('.pseudocode-line').forEach(line => {
                    line.classList.remove('current', 'completed', 'error');
                });
            }

            toggleAutoRun() {
                if (this.autoRunning) {
                    this.autoRunning = false;
                    this.updateButtons();
                } else {
                    if (!this.isRunning) {
                        this.start();
                    }
                    this.autoRunning = true;
                    this.updateButtons();
                    this.autoExecute();
                }
            }

            autoExecute() {
                if (this.autoRunning && this.isRunning) {
                    this.nextStep();
                    if (this.isRunning) {
                        const delay = 3100 - (this.autoRunSpeed * 300);
                        setTimeout(() => this.autoExecute(), delay);
                    }
                }
            }

            nextStep() {
                if (!this.isRunning) return;

                // If this is the first step or we just executed a line, move to next line
                // BUT if we have a pending return, we need to stay on the current line to re-execute
                if (!this.executionContext.waitingForExecution && !this.executionContext.pendingReturn) {
                    this.currentStep++;

                    if (this.currentStep >= this.parsedCode.length) {
                        this.isRunning = false;
                        this.autoRunning = false;
                        this.updateButtons();
                        this.updateDebugInfo();
                        return;
                    }

                    // Highlight the line and wait for execution
                    this.highlightLine(this.currentStep);
                    this.executionContext.waitingForExecution = true;

                    // Check for breakpoint - pause auto-run if we hit one
                    if (this.breakpoints.has(this.currentStep)) {
                        if (this.autoRunning) {
                            this.autoRunning = false;
                        }
                        this.executionContext.breakpointPaused = true;
                    } else {
                        this.executionContext.breakpointPaused = false;
                    }

                    this.updateButtons();
                    this.updateDebugInfo();
                    return;
                }

                // Execute the currently highlighted line
                this.saveExecutionState();
                this.stepCounter++;

                this.executeStep(this.parsedCode[this.currentStep]);

                // Check if next line is END FOR/END WHILE and we need to continue loop
                this.checkLoopContinuation();

                this.executionContext.waitingForExecution = false;

                // Now move to next line (recursive call)
                this.nextStep();
            }

            checkLoopContinuation() {
                // Check if the next line is END FOR or END WHILE
                const nextLineIndex = this.currentStep + 1;
                if (nextLineIndex >= this.parsedCode.length) return;

                const nextLine = this.parsedCode[nextLineIndex].trim();

                if (nextLine === 'END FOR') {
                    const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                    if (loop && loop.type === 'FOR') {
                        const currentVal = this.variables[loop.varName];
                        const stepVal = loop.stepVal || 1;
                        const nextVal = currentVal + stepVal;

                        // Check if loop should continue based on step direction
                        const shouldContinue = stepVal > 0 ?
                            nextVal <= loop.endVal :
                            nextVal >= loop.endVal;

                        if (shouldContinue) {
                            // Continue loop: apply step and jump back to FOR line
                            this.updateVariable(loop.varName, nextVal);
                            this.currentStep = loop.startLine - 1; // -1 because nextStep() will increment
                            return;
                        }
                    }
                } else if (nextLine === 'END WHILE') {
                    const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                    if (loop && loop.type === 'WHILE') {
                        const result = this.evaluateCondition(loop.condition);
                        if (result) {
                            // Continue loop: jump back to WHILE line
                            this.currentStep = loop.startLine - 1; // -1 because nextStep() will increment
                            return;
                        }
                    }
                }
            }

            executeStep(line) {
                try {
                    const trimmedLine = line.trim();

                    // Handle main program structure
                    if (trimmedLine === 'BEGIN') {
                        // Begin main program execution - no special action needed
                        return;
                    } else if (trimmedLine === 'END') {
                        // End of main program - no special action needed
                        return;
                    }
                    // Handle function/method definitions (skip during main execution)
                    else if (trimmedLine.startsWith('FUNCTION ') || trimmedLine.startsWith('METHOD ')) {
                        // Skip function definitions during main execution
                        this.skipToEnd(trimmedLine.startsWith('FUNCTION') ? 'FUNCTION' : 'METHOD');
                        return;
                    } else if (trimmedLine.match(/^END (FUNCTION|METHOD)$/)) {
                        const endType = trimmedLine.split(' ')[1];
                        if (this.executionContext.inFunction && this.executionContext.callStack.length > 0) {
                            // We're at the end of a function or method execution
                            const callFrame = this.executionContext.callStack[this.executionContext.callStack.length - 1];
                            if (endType === 'METHOD' || (callFrame && callFrame.isMethod)) {
                                // Methods don't need explicit RETURN - auto return at END METHOD
                                this.returnFromFunction(undefined);
                            } else {
                                // Functions must have explicit RETURN statements
                                throw new Error(`Function must have explicit RETURN statement`);
                            }
                        }
                        // When not in a function/method, this is reached when skipping definitions
                        return;
                    }
                    // Handle variable assignments
                    else if (trimmedLine.includes('‚Üê') && !trimmedLine.startsWith('IF ') && !trimmedLine.startsWith('ELSE IF ') &&
                        !trimmedLine.startsWith('WHILE ') && !trimmedLine.startsWith('FOR ') &&
                        !trimmedLine.startsWith('OUTPUT ') && !trimmedLine.startsWith('PRINT ') &&
                        !trimmedLine.startsWith('FUNCTION ') && !trimmedLine.startsWith('METHOD ')) {

                        console.log('Executing assignment:', trimmedLine); // Debug
                        const parts = trimmedLine.split('‚Üê');
                        if (parts.length === 2) {
                            const varName = parts[0].trim();
                            console.log('Variable name:', varName); // Debug
                            const value = this.evaluateExpression(parts[1].trim());
                            console.log('Computed value:', value); // Debug
                            this.updateVariable(varName, value);
                            console.log('Assignment completed'); // Debug
                        }
                    } else if (trimmedLine.startsWith('OUTPUT ')) {
                        const expr = trimmedLine.substring(7);
                        const value = this.evaluateExpression(expr);
                        this.addOutput(String(value));
                    } else if (trimmedLine.startsWith('PRINT ')) {
                        const expr = trimmedLine.substring(6);
                        const value = this.evaluateExpression(expr);
                        this.addOutput(String(value));
                    } else if (trimmedLine.startsWith('IF ')) {
                        const thenIndex = trimmedLine.indexOf('THEN');
                        if (thenIndex > 0) {
                            const condition = trimmedLine.substring(3, thenIndex).trim();
                            const result = this.evaluateCondition(condition);

                            this.executionContext.ifStack.push({
                                startLine: this.currentStep,
                                conditionMet: result,
                                hasExecuted: result
                            });

                            if (!result) {
                                this.skipToNextIfBlock();
                            }
                        }
                    } else if (trimmedLine.startsWith('ELSE IF ')) {
                        const currentIf = this.executionContext.ifStack[this.executionContext.ifStack.length - 1];
                        if (currentIf && !currentIf.hasExecuted) {
                            const thenIndex = trimmedLine.indexOf('THEN');
                            if (thenIndex > 0) {
                                const condition = trimmedLine.substring(8, thenIndex).trim();
                                const result = this.evaluateCondition(condition);

                                if (result) {
                                    currentIf.hasExecuted = true;
                                    currentIf.conditionMet = true;
                                } else {
                                    this.skipToNextIfBlock();
                                }
                            }
                        } else {
                            this.skipToEndIf();
                        }
                    } else if (trimmedLine === 'ELSE') {
                        const currentIf = this.executionContext.ifStack[this.executionContext.ifStack.length - 1];
                        if (currentIf && currentIf.hasExecuted) {
                            this.skipToEndIf();
                        }
                    } else if (trimmedLine === 'END IF') {
                        this.executionContext.ifStack.pop();
                    } else if (trimmedLine.startsWith('WHILE ')) {
                        const doIndex = trimmedLine.indexOf('DO');
                        if (doIndex > 0) {
                            const condition = trimmedLine.substring(6, doIndex).trim();
                            const result = this.evaluateCondition(condition);
                            if (result) {
                                this.executionContext.loopStacks.push({
                                    type: 'WHILE',
                                    startLine: this.currentStep,
                                    condition: condition
                                });
                            } else {
                                this.skipToEnd('WHILE');
                            }
                        }
                    } else if (trimmedLine === 'END WHILE') {
                        // Only reached when loop actually ends (checkLoopContinuation handles continuation)
                        const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                        if (loop && loop.type === 'WHILE') {
                            this.executionContext.loopStacks.pop();
                        }
                    } else if (trimmedLine.startsWith('FOR ')) {
                        // Match both "FOR var ‚Üê start TO end DO" and "FOR var ‚Üê start TO end STEP increment DO"
                        const match = trimmedLine.match(/FOR (\w+) ‚Üê (.+) TO (.+?)(?:\s+STEP\s+(.+?))?\s+DO/);
                        if (match) {
                            const varName = match[1];
                            const startVal = this.evaluateExpression(match[2]);
                            const endVal = this.evaluateExpression(match[3]);
                            const stepVal = match[4] ? this.evaluateExpression(match[4]) : 1;

                            // Only set the variable to startVal on the first execution (when loop is not yet in stack)
                            if (!this.executionContext.loopStacks.find(loop => loop.type === 'FOR' && loop.varName === varName)) {
                                this.updateVariable(varName, startVal);
                            }
                            // If loop is already in stack, we're continuing - don't change the variable

                            // Check if loop should execute based on current variable value and step direction
                            const currentVal = this.variables[varName];
                            const shouldExecute = stepVal > 0 ?
                                currentVal <= endVal :
                                currentVal >= endVal;

                            if (shouldExecute) {
                                // Only push to loop stack if this is the first execution
                                if (!this.executionContext.loopStacks.find(loop => loop.type === 'FOR' && loop.varName === varName)) {
                                    this.executionContext.loopStacks.push({
                                        type: 'FOR',
                                        startLine: this.currentStep,
                                        varName: varName,
                                        endVal: endVal,
                                        stepVal: stepVal
                                    });
                                }
                            } else {
                                this.skipToEnd('FOR');
                            }
                        }
                    } else if (trimmedLine === 'END FOR') {
                        // Only reached when loop actually ends (checkLoopContinuation handles continuation)
                        const loop = this.executionContext.loopStacks[this.executionContext.loopStacks.length - 1];
                        if (loop && loop.type === 'FOR') {
                            this.executionContext.loopStacks.pop();
                        }
                    } else if (trimmedLine.startsWith('RETURN ')) {
                        if (this.executionContext.inFunction && this.executionContext.callStack.length > 0) {
                            // Handle return from function
                            const returnExpr = trimmedLine.substring(7).trim();
                            const returnValue = this.evaluateExpression(returnExpr);
                            this.returnFromFunction(returnValue);
                        } else {
                            // Handle return statement in main program (shouldn't happen, but for safety)
                            const returnExpr = trimmedLine.substring(7).trim();
                            const returnValue = this.evaluateExpression(returnExpr);
                            this.addOutput(`RETURN: ${returnValue}`);
                            this.isRunning = false;
                        }
                    } else if (trimmedLine === 'RETURN') {
                        if (this.executionContext.inFunction && this.executionContext.callStack.length > 0) {
                            // Handle return from function without value
                            this.returnFromFunction(undefined);
                        } else {
                            // Handle return without value in main program
                            this.addOutput(`RETURN`);
                            this.isRunning = false;
                        }
                    }
                    // Handle standalone method calls (not assignments or prints)
                    else {
                        const methodCallMatch = trimmedLine.match(/^(\w+)\s*\(/);
                        if (methodCallMatch) {
                            const methodName = methodCallMatch[1];
                            if (this.executionContext.functions[methodName] &&
                                this.executionContext.functions[methodName].type === 'METHOD') {
                                // This is a standalone method call
                                this.callMethod(methodName, trimmedLine);
                            }
                        }
                    }
                } catch (error) {
                    if (error instanceof FunctionCallException) {
                        // Function call initiated - execution will continue from function
                        // Don't treat this as an error
                        return;
                    } else if (error instanceof MethodCallException) {
                        // Method call initiated - execution will continue from method
                        // Don't treat this as an error
                        return;
                    }

                    this.addOutput(`Error: ${error.message}`);
                    const currentLine = document.querySelector(`[data-line="${this.currentStep}"]`);
                    if (currentLine) {
                        currentLine.classList.add('error');
                    }
                }
            }

            skipToNextIfBlock() {
                let depth = 0;
                while (this.currentStep + 1 < this.parsedCode.length) {
                    this.currentStep++;
                    const line = this.parsedCode[this.currentStep];
                    
                    if (line.startsWith('IF ')) {
                        depth++;
                    } else if (line === 'END IF') {
                        if (depth === 0) {
                            this.currentStep--;
                            return;
                        }
                        depth--;
                    } else if (depth === 0 && (line.startsWith('ELSE IF ') || line === 'ELSE')) {
                        this.currentStep--;
                        return;
                    }
                }
            }

            skipToEndIf() {
                let depth = 0;
                while (this.currentStep + 1 < this.parsedCode.length) {
                    this.currentStep++;
                    const line = this.parsedCode[this.currentStep];
                    
                    if (line.startsWith('IF ')) {
                        depth++;
                    } else if (line === 'END IF') {
                        if (depth === 0) {
                            this.currentStep--;
                            return;
                        }
                        depth--;
                    }
                }
            }

            skipToEnd(blockType) {
                let depth = 1;
                while (this.currentStep + 1 < this.parsedCode.length && depth > 0) {
                    this.currentStep++;
                    const line = this.parsedCode[this.currentStep];
                    
                    if (line.startsWith(blockType + ' ') || 
                        (blockType === 'IF' && line.startsWith('IF ')) ||
                        (blockType === 'WHILE' && line.startsWith('WHILE ')) ||
                        (blockType === 'FOR' && line.startsWith('FOR '))) {
                        depth++;
                    } else if (line === `END ${blockType}`) {
                        depth--;
                    }
                }
            }

            showHelp() {
                document.getElementById('helpModal').style.display = 'block';
            }

            updateButtons() {
                const startBtn = document.getElementById('startBtn');
                const nextBtn = document.getElementById('nextBtn');
                const prevBtn = document.getElementById('prevBtn');
                const autoBtn = document.getElementById('autoBtn');

                startBtn.disabled = this.parsedCode.length === 0 || this.isRunning;
                nextBtn.disabled = !this.isRunning || this.autoRunning;
                prevBtn.disabled = !this.isRunning || this.executionHistory.length === 0;
                autoBtn.disabled = this.parsedCode.length === 0;
                autoBtn.textContent = this.autoRunning ? 'Pause Auto' : 'Auto Run';
            }

            updateDebugInfo() {
                document.getElementById('stepCounter').textContent = this.stepCounter;
                document.getElementById('breakpointCount').textContent = this.breakpoints.size;
                
                let status = 'Ready';
                if (this.isRunning) {
                    if (this.autoRunning) {
                        status = 'Auto Running';
                    } else if (this.breakpoints.has(this.currentStep)) {
                        status = 'Paused at Breakpoint';
                    } else if (this.executionContext.waitingForExecution) {
                        status = 'Ready to Execute';
                    } else {
                        status = 'Running (Manual)';
                    }
                } else if (this.currentStep >= this.parsedCode.length - 1 && this.stepCounter > 0) {
                    status = 'Completed';
                }
                
                document.getElementById('executionStatus').textContent = status;
            }

            updateSpeedLabel() {
                const speedLabel = document.getElementById('speedLabel');
                const speedNames = {
                    1: 'Very Slow',
                    2: 'Slow',
                    3: 'Slow',
                    4: 'Medium',
                    5: 'Normal',
                    6: 'Normal',
                    7: 'Fast',
                    8: 'Fast',
                    9: 'Very Fast',
                    10: 'Maximum'
                };
                speedLabel.textContent = speedNames[this.autoRunSpeed] || 'Normal';
            }
        }

        // Initialize the animator when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            new MathematicalPseudocodeAnimator();
        });
    </script>
</body>
</html>